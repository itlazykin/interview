## DataStructuresAndAlgorithms

[Что такое структуры данных в программировании? Какие бывают?](#что-такое-структуры-данных-в-программировании-какие-бывают)

[Что такое Java Collections](#что-такое-java-collections)

[Расскажите про интерфейс Iterable и Iterator](#расскажите-про-интерфейс-iterable-и-iterator)

[Расскажите про интерфейс List и его реализации](#расскажите-про-интерфейс-list-и-его-реализации)

[Что такое ArrayList?](#что-такое-arraylist)

[Что такое LinkedList?](#что-такое-LinkedList)

[ArrayList vs LinkedList](#arraylist-vs-linkedlist)

[Расскажите про интерфейс Queue](#расскажите-про-интерфейс-queue)

[Расскажите про интерфейс Deque](#расскажите-про-интерфейс-deque)

[Расскажите про интерфейс Set и его реализации](#расскажите-про-интерфейс-set-и-его-реализации)

[Расскажите про интерфейс Map и его реализации](#расскажите-про-интерфейс-map-и-его-реализации)

[Расскажите о методах keySet и entrySet? Что такое Entry?](#расскажите-о-методах-keyset-и-entryset-что-такое-entry)

[Расскажите, что такое коллизии в Map? Как с ними бороться?](#расскажите-что-такое-коллизии-в-map-как-с-ними-бороться)

[Что такое TreeMap?](#что-такое-treemap)

[HashMap vs TreeMap](#hashmap-vs-treemap)

[Реализации интерфейса Map. Почему интерфейс Map выделен отдельно?](#реализации-интерфейса-map-почему-интерфейс-map-выделен-отдельно)

[Расскажите про методы Object hashCode и equals?](#расскажите-про-методы-object-hashcode-и-equals)

[Big O](#big-o)

[Алгоритмы сортировки и их сложность, какая сортировка используется в java](#алгоритмы-сортировки-и-их-сложность-какая-сортировка-используется-в-java)

[Алгоритм линейного поиска](#алгоритм-линейного-поиска)

[Алгоритм бинарного поиска](#алгоритм-бинарного-поиска)

[Как с собой связаны Iterable и foreach?](#как-с-собой-связаны-iterable-и-foreach)

[HashTable - что это такое?](#как-с-собой-связаны-iterable-и-foreach)

[Arrays.asList() and List.of() ](#как-с-собой-связаны-iterable-и-foreach)

# Что такое структуры данных в программировании? Какие бывают?

Структуры данных — это способы организации/хранения/работы с данными, которые
позволяют эффективно выполнять операции над ними (добавление, удаление, поиск, сортировка и т.д.).

### Какие бывают:

+ Граф - набор объектов(вершин) и их связей (рёбер).

![graph.png](../../../resources/graph.png)

+ Дерево - это иерархическая структура данных, состоящая из узлов (вершин) и ребер (дуг). Деревья по сути связанные
  графы без циклов.

![three.png](../../../resources/three.png)

+ Массив - структура данных, хранящая линейную последовательность элементов идентифицируемых по индексу.

![array.png](../../../resources/array.png)

+ Связный список – массив, где каждый элемент является отдельным объектом и состоит из двух элементов – данных и ссылки
  на следующий узел.

![linkedlist.png](../../../resources/linkedlist.png)

+ Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in —
  first out, «последним пришёл — первым вышел»).

![stack.png](../../../resources/stack.png)

+ Очередь - абстрактный тип данных, представляющий собой список элементов, организованных по принципу FIFO  (англ. First
  in First Out, «последним пришёл — первым вышел»).

![queue.png](../../../resources/queue.png)

+ Хэш таблица - структура данных, в которой все элементы хранятся в виде пары ключ - значение.

![hashtable.png](../../../resources/hashtable.png)

[К оглавлению](#DataStructuresAndAlgorithms)

# Что такое Java Collections

Это набор интерфейсов и классов в Java для хранения и управления группами объектов (данных). Это часть
стандартной библиотеки (java.util.*), которая упрощает работу с данными, предоставляя готовые реализации популярных
структур данных. Нельзя хранить примитивные типы.

![Collections.png](../../../resources/Collections.png)

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

+ `add(Object o)` - добавляет элемент в коллекцию.
+ `iterator()` - возвращает итератор для перебора элементов коллекции.
+ `remove(Object o)` - удаляет элемент из коллекции.
+ `contains(Object o)` - проверяет, есть ли элемент в коллекции.
+ `size()` - возвращает количество элементов в коллекции.
+ `clear()` - очищает коллекцию (удаляет все элементы).
+ `toArray()` - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс Iterable и Iterator

+ Iterable корневой интерфейс всех классов коллекций. У интерфейса Iterable определен только один метод iterator().
  Класс, реализующий Iterable, может быть использован в улучшенном
  цикле for-each.
+ Iterator - интерфейс, который предоставляет методы для последовательного доступа к элементам коллекции.
    + `boolean hasNext()` - вернет true, сли в коллекции есть следующий элемент, который можно извлечь методом `next()`
    + `E next()` - вернет следующий элемент из коллекции.
    + `void remove()` - удалит текущий элемент, может быть вызван только после метода `next()`

### Виды итераторов.

+ `Fail-fast` были добавлены в Java для обеспечения безопасности при работе с многопоточными коллекциями. Итераторы бросают исключение `ConcurrentModificationException`, если коллекция модифицируется (добавление,
  удаление, изменение элементов) в процессе итерации любым способом, кроме использования методов самого итератора (
  например, remove() у итератора).

Как работает `fail-fast` механизм: Итераторы `fail-fast` проверяют "структурные модификации" коллекции при каждом вызове
метода, такого как `next()` или `remove()`. Внутри коллекции есть счетчик модификаций (modification count), который
увеличивается при структурных изменениях. Итератор сохраняет значение этого счетчика на момент своего создания и
сравнивает его с текущим значением при каждой операции. Если значения не совпадают (например, элемент был добавлен или
удален через саму коллекцию, а не через итератор), то генерируется `ConcurrentModificationException`.

+ `Fail-safe` итераторы не бросают исключение при модификации коллекции во время итерации. Вместо этого они работают с
  копией данных коллекции, что позволяет избежать конфликтов.

Как работает `fail-safe` механизм: `Fail-safe` итераторы работают с клоном коллекции. Это означает, что любые изменения,
внесенные в коллекцию после создания итератора, не видны итератору. Такие итераторы обеспечивают безопасный доступ, но
изменения в коллекции не отражаются на итераторе.

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс List и его реализации

Представляет упорядоченную коллекцию объектов, которая может содержать дублирующиеся элементы. Поддерживает доступ по
индексу(элементы списка можно напрямую получать, добавлять, изменять или удалять, используя индекс, который представляет
позицию элемента в списке.)

![listmethod.png](../../../resources/listmethod.png)

### Реализации.

+ `ArrayList`
+ `LinkedList`
+ `Vector` - реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве
  элемента.
  Vector появился в JDK версии Java 1.0, использовать если требуется достижения потокобезопасности.
+ `Stack` - Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её
  основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому,
  добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца
  за
  константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь.

[К оглавлению](#DataStructuresAndAlgorithms)

# Что такое ArrayList?

Это список, реализованный на основе динамически расширяемого массива. То есть под капотом буквально создается массив

### Какая размерность массива по умолчанию?

Capacity = 10

### Можно ли задать начальную емкость/размер списка?

Да, через конструктор (List<String> list = new ArrayList<String>(15))

### Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?

`Добавление в конец списка:`

1. Проверяется достаточно ли места для добавления нового элемента.

Если достаточно, то переходим к п. 2, если нет:

+ Создается новый массив размером в 1.5 раза больше
+ Копируются все элементы из старого массива

2. Новый элемент добавляется в конец

`Добавление в начало/середину списка:`

1. Проверяется достаточно ли места для добавления нового элемента.

Если достаточно, то переходим к п. 2, если нет:

+ Создается новый массив размером в 1.5 раза больше
+ Копируются все элементы из старого массива

2. Все элементы, начиная с нужного индекса, сдвигаются на один вправо
3. Элемент с нужным индексом перезаписывается новым значением

Описанные операции копирования и сдвига элементов осуществляются функцией System.arraycopy(). Т.е. в случае добавления в
конец списка System.arraycopy() будет вызвана 0 или 1 раз, в случае добавления в середину — 1 или 2 раза.

### Сложность операций:

`Какая скорость добавления элемента в начало/середину/конец списка?`

| Место добавления | Средняя сложность | Худшая сложность | Пояснение                                                                                   |
|------------------|-------------------|------------------|---------------------------------------------------------------------------------------------|
| Начало списка    | O(n)              | O(n)             | Все элементы сдвигаются вправо для освобождения места.                                      |
| Середина списка  | O(n)              | O(n)             | Элементы после точки вставки сдвигаются вправо.                                             |
| Конец списка     | O(1)              | O(n)             | Амортизированная сложность O(1), но если массив переполняется, требуется перераспределение. |

`Какая скорость удаления элемента в начале/середине/конце списка?`

| Место добавления | Средняя сложность | Худшая сложность | Пояснение                                                                              |
|------------------|-------------------|------------------|----------------------------------------------------------------------------------------|
| Начало списка    | O(n)              | O(n)             | Все элементы сдвигаются влево для заполнения освободившегося места.                    |
| Середина списка  | O(n)              | O(n)             | Элементы после удалённого элемента сдвигаются влево.                                   |
| Конец списка     | O(1)              | O(n)             | Удаление последнего элемента происходит мгновенно без необходимости сдвигать элементы. |

`Какая скорость доступа по индексу и значению?`

| Место добавления  | Средняя сложность | Худшая сложность | Пояснение                                                                            |
|-------------------|-------------------|------------------|--------------------------------------------------------------------------------------|
| Доступ по индексу | O(1)              | O(1)             | Прямой доступ к элементам массива за константное время благодаря индексации.         |
| Поиск по значению | O(n)              | O(n)             | Линейный поиск, так как элементы не отсортированы и требуется перебор всех значений. |

### Сложность по времени ArrayList.contains()

Время выполнения: O(n), где n — количество элементов. `contains()` выполняет линейный поиск, сравнивая элементы по
порядку.

[К оглавлению](#DataStructuresAndAlgorithms)

# Что такое LinkedList

Классический двусвязный список, основанный на объектах со ссылками между ними. Реализует интерфейсы List и Deque. Данные
хранятся в объектах типа Node. В LinkedList элементы фактически представляют собой звенья одной цепи. У каждого элемента
помимо тех данных, которые он хранит, имеется ссылка на предыдущий и следующий элемент. По этим ссылкам можно переходить
от одного элемента к другому.

### Что происходит под капотом при добавлении/удалении элемента в начало/середину/конец списка?

При создании LinkedList-а, у нас создается псевдо элемент - Header в котором хранятся next и prev, которые пока
указывают сами на себя. После добавления элемента, ссылки next и prev у каждого объекта будут указывать на предыдущий и
следующий

### Сложность операций

`Какая скорость добавления элемента в начало/середину/конец списка?`

| Место добавления | Средняя сложность | Худшая сложность | Пояснение                                                                |
|------------------|-------------------|------------------|--------------------------------------------------------------------------|
| Начало списка    | O(1)              | O(1)             | Новый узел добавляется перед первым, переназначаются ссылки.             |
| Середина списка  | O(n)              | O(n)             | Требуется пройти список до нужного узла, после чего выполняется вставка. |
| Конец списка     | O(1)              | O(1)             | Новый узел добавляется после последнего, переназначаются ссылки.         |

`Какая скорость удаления элемента в начале/середине/конце списка?`

| Место добавления | Средняя сложность | Худшая сложность | Пояснение                                                                               |
|------------------|-------------------|------------------|-----------------------------------------------------------------------------------------|
| Начало списка    | O(1)              | O(1)             | Удаление первого узла выполняется мгновенно, ссылки переназначаются.                    |
| Середина списка  | O(n)              | O(n)             | Требуется пройти список до нужного узла, после чего выполняется удаление.               |
| Конец списка     | O(1)              | O(1)             | Удаление последнего узла выполняется мгновенно, если есть доступ к последнему элементу. |

`Какая скорость доступа по индексу и значению`

| Место добавления              | Средняя сложность | Худшая сложность | Пояснение                                                           |
|-------------------------------|-------------------|------------------|---------------------------------------------------------------------|
| Доступ по первому элементу    | O(1)              | O(1)             | Первый элемент хранится в ссылке head, доступ к нему мгновенный.    |
| Доступ по последнему элементу | O(1)              | O(1)             | Последний элемент хранится в ссылке tail, доступ к нему мгновенный. |
| Доступ по индексу             | O(n)              | O(n)             | Линейный обход от начала или конца до нужного индекса.              |
| Доступ по значению            | O(n)              | O(n)             | Линейный перебор всех элементов до нахождения искомого значения.    |

[К оглавлению](#DataStructuresAndAlgorithms)

# ArrayList vs LinkedList

| Критерий              | ArrayList                                            | LinkedList                                       |
|-----------------------|------------------------------------------------------|--------------------------------------------------|
| Расположение в памяти | Последовательные блоки памяти (массив).              | Элементы связаны через указатели.                |
| Добавление в конец    | O(1) (если есть место) или O(n) (при расширении).    | O(1)                                             |
| Добавление в начало   | O(n) (сдвиг всех элементов).                         | O(1)                                             |
| Добавление в середину | O(n) (сдвиг элементов).                              | O(n) (поиск нужной позиции + изменение ссылок).  |
| Удаление элемента     | O(n) (сдвиг оставшихся элементов).                   | O(n) (поиск) или O(1) (если указатель известен). |
| Поиск по индексу      | O(1).                                                | O(n) (идём по ссылкам).                          |
| Поиск по значению     | O(n).                                                | O(n).                                            |
| Память                | Использует меньше памяти, т.к. хранит только данные. | Использует больше памяти, т.к. хранит ссылки.    |

### Где какой использовать?

+ ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное
  время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того в ArrayList нет
  дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся
  не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.
+ LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за
  константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря что ближе) до нужного
  элемента. Дополнительные затраты на хранение связки между элементами.

Одним словом - если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList

### Какая скорость вставки в отсортированный массив ArrayList и LinkedList

+ ArrayList:
    + Сложность: O(n), так как требуется сдвиг элементов, чтобы освободить место для нового элемента.
    + Подходит, если вставки происходят редко.

+ LinkedList:
    + Сложность: O(n), так как требуется найти позицию для вставки (линейный поиск) и изменить ссылки.
    + Лучше подходит для частых операций вставки, особенно в начале / конце списка.

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс Queue

Queue - это интерфейс в Java, который представляет собой коллекцию элементов, работающую по принципу “первый вошел — первый вышел” (FIFO — First In, First Out). Сложность операций О(1).

+ `add(E element)` Добавляет элемент в конец очереди. IllegalStateException (если очередь заполнена).
+ `offer(E element)` Добавляет элемент в конец очереди. Возвращает false при переполнении.
+ `remove()` Удаляет и возвращает элемент из начала очереди. NoSuchElementException (если пуста).
+ `poll()` Удаляет и возвращает элемент из начала очереди. Возвращает null при пустой очереди.
+ `element()` Возвращает элемент из начала очереди без удаления. NoSuchElementException (если пуста).
+ `peek()` Возвращает элемент из начала очереди без удаления. Возвращает null при пустой очереди.

Популярные реализации:

+ `LinkedList` — базовая реализация (неограниченная очередь).
+ `ArrayBlockingQueue` — очередь с фиксированным размером и блокировками.
+ `PriorityQueue` — очередь с приоритетом (не FIFO!).
+ `ArrayDeque` - реализация на основе массива

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс Deque

Deque (Double-Ended Queue) — это интерфейс в Java, который представляет собой очередь с двумя концами. Это означает, что элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Таким образом, Deque может работать как очередь (FIFO) и как стек (LIFO). Сложность операций О(1).

`void addFirst(E element)` Добавляет элемент в начало очереди. IllegalStateException при переполнении
`void addLast(E element)` Добавляет элемент в конец очереди. IllegalStateException при переполнении
`boolean offerFirst(E e)` Добавляет элемент в начало очереди. Возвращает false при переполнении
`boolean offerLast(E e)` Добавляет элемент в конец очереди. Возвращает false при переполнении
`E removeFirst()` Удаляет и возвращает первый элемент. NoSuchElementException если пуста
`E removeLast()` Удаляет и возвращает последний элемент. NoSuchElementException если пуста
`E pollFirst()` Удаляет и возвращает первый элемент. Возвращает null если пуста
`E pollLast()` Удаляет и возвращает последний элемент. Возвращает null если пуста
`E getFirst()` Возвращает первый элемент без удаления. NoSuchElementException если пуста
`E getLast()` Возвращает последний элемент без удаления. NoSuchElementException если пуста
`E peekFirst()` Возвращает первый элемент без удаления. Возвращает null если пуста
`E peekLast()` Возвращает последний элемент без удаления. Возвращает null если пуста

Популярные реализации:

+ `ArrayDeque` - реализация на основе массива
+ `LinkedList` - реализация на основе связного списка

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс Set и его реализации

Интерфейс Set определяет множество (набор). Set расширяет Collection и определяет поведение коллекции, не допускающей
дублирования элементов, уникальность которых определяется методом equals().

+ `boolean add(E element)` — добавляет элемент, если элемент уже присутствует, возвращает false.
+ `boolean remove(Object element)` — удаляет указанный элемент из множества, если он присутствует. Возвращает true, если
  элемент был удален, и false в противном случае.
+ `boolean contains(Object element)` — проверяет, содержит ли множество указанный элемент. Возвращает true, если элемент
  присутствует, и false в противном случае.
+ `boolean isEmpty()` — проверяет, является ли множество пустым. Возвращает true, если множество не содержит элементов,
  и
  false в противном случае.
+ `boolean addAll/removeAll(Collection<?> elements)` — добавляет/удаляет элементы из указанной коллекции в/из множества.
  Возвращает true, если множество изменилось в результате вызова метода.

### Реализации:

+ `HashSet` — Особенности:
    + выгода от хеширования состоит в том, что оно обеспечивает постоянное время выполнения операций add(), contains(),
      remove() и size(), даже для больших наборов.
    + класс HashSet не гарантирует упорядоченность элементов, поскольку процесс хеширования сам по себе обычно не
      приводит к созданию отсортированных множеств.
    + под капотом HashSet находится HashMap, а сама структура HashSet — это набор ключей HashMap.
+ `TreeSet` — реализация Set на основе сбалансированного дерева (обычно красно-черного дерева). Элементы в TreeSet
  хранятся в отсортированном порядке по их естественному порядку или с использованием заданного компаратора.
+ `LinkedHashSet` — реализация Set, которая объединяет хэш-таблицы с двусвязным списком. Элементы в LinkedHashSet
  упорядочены в порядке их вставки.

### Процесс добавления объекта в HashSet?

HashSet использует HashMap под капотом: объекты являются ключами, а вместо значений используется константа-заглушка.
Поэтому алгоритм добавления идентичен HashMap (элемент HashSet == ключ HashMap)

1. Вычисляем хэш-код объекта и бакет, в который будем добавлять объект
2. Если бакет пустой — объект добавляется в бакет, если нет:

+ идем по ключам элементов связного списка (или TreeMap) и сравниваем с добавляемым объектом по хеш-коду и equals()
+ если ключ элемента и объект равны — добавление игнорируется, если нет — переходим к следующему элементу
+ если совпадений не найдено — добавляем объект в конец связного списка (или в TreeMap)

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про интерфейс Map и его реализации

Ассоциативный массив, хранит пары “ключ-значение”. Ключ-уникальный, значение-может повторяться. Уникальность ключей
определяется методом equals(), поэтому предпочтительно использовать immutable(неизменяемые) - класс, экземпляры которого
не могут быть изменены после создания(например String).
Потому что, если изменить объект на котором основан ключ, то у него поменяется хеш-код найти элемент в HashMap-е не
получится. Для корректной работы необходимо переопределить методы equals() и hashCode() Каждая
ячейка массива - бакет(корзина), хранящий в себе односвязный список узлов. Может содержать
один ключ null и любое количество значений null. Не отсортирован и не упорядочен. Возможны коллизии - возникают, когда у
разных объектов одинаковые хеш-коды. Если у односвязного списка node больше 8 элементов (коллизии),
он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6.

+ `V put(K key, V value)` Добавляет пару "ключ-значение" в Map. Если ключ уже существует, заменяет старое значение на
  новое и возвращает старое значение.
+ `V get(Object key)` Возвращает значение, связанное с указанным ключом. Если ключ не найден, возвращает null.
+ `boolean containsKey(Object key)` Проверяет, содержит ли Map указанный ключ. Возвращает true, если ключ существует, и
  false в противном случае.
+ `boolean containsValue(Object value)` Проверяет, содержит ли Map указанное значение. Возвращает true, если значение
  существует, и false в противном случае.
+ `V remove(Object key)` Удаляет пару "ключ-значение" по ключу. Возвращает значение, которое было связано с удаленным
  ключом, или null, если ключ не найден.
+ `void clear()` Очищает Map, удаляя все элементы.
+ `int size()` Возвращает количество пар "ключ-значение" в Map.
+ `boolean isEmpty()` Проверяет, пуст ли Map. Возвращает true, если Map не содержит элементов, и false в противном
  случае.
+ `Set<K> keySet()` Возвращает Set, содержащий все ключи в Map.
+ `Collection<V> values()` Возвращает коллекцию значений, содержащихся в Map.
+ `Set<Map.Entry<K, V>> entrySet()` Возвращает набор (Set) всех записей (пар "ключ-значение") в Map.

### Сложность операций:

| Операция                                       | Средняя сложность | Худшая сложность | Пояснение                                                                                                                                                                            |
|------------------------------------------------|-------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Добавление (put)                               | O(1)              | O(n)             | В среднем: хеш-функция вычисляет индекс за константное время. В худшем случае — при множестве коллизий — все элементы хранятся в одной корзине как связный список или дерево (O(n)). |
| Удаление (remove)                              | O(1)              | O(n)             | Удаление элемента по ключу быстрое в среднем. При множестве коллизий потребуется обход корзины.                                                                                      |
| Поиск (get)                                    | O(1)              | O(n)             | В среднем: доступ по хешу за константное время. В худшем случае — линейный обход корзины.                                                                                            |
| Проверка наличия (containsKey / containsValue) | O(1) / O(n)       | O(n)             | Проверка ключа быстрая в среднем (O(1)), для значений требуется полный перебор (O(n)).                                                                                               |
| Итерация по элементам                          | O(n)              | O(n)             | Обход всех элементов требует линейное время, так как необходимо пройти все корзины.                                                                                                  |

### Устройство HashMap

В HashMap бакет — это элемент массива, в котором хранятся записи (ключ-значение). Если у нескольких ключей совпадает
хеш, их записи попадают в один бакет, где организуются в виде связного списка или сбалансированного дерева (в
зависимости от Java версии). Изначально создается 16 бакетов. Если массив бакетов заполнен на 75 процентов - создается
х2 от начального размера.

Чтобы определить номер бакета есть формула: `bucketIndex = (hash & (capacity - 1))`; Операция побитового & (AND)
используется вместо %, так как она быстрее и эффективнее для степеней двойки.

`hash` — хэш-код ключа, который возвращает метод key.hashCode().
`capacity` — текущая ёмкость таблицы (всегда степень двойки, например, 16, 32).
`bucketIndex` — индекс бакета, в котором будет храниться элемент.
`loadFactor` - это коэффициент загрузки, на основании его значения вычисляется предельное количество занятых бакетов.
При достижении порогового значения размер коллекции увеличивается.

### Как работает HashMap

1) Добавление элемента (put)

Метод hashCode() ключа вычисляет целочисленный хэш-код. Если бакет пуст, элемент добавляется напрямую. Если бакет уже
содержит элементы (коллизия), происходит:

+ идем по ключам элементов связного списка (или TreeMap) и сравниваем с ключом добавляемого элемента по хеш-коду и
  equals()
+ если ключи равны — перезаписываем значение по этому ключу, если нет — переходим к следующему элементу
+ если не нашли ключ добавляемого элемента (равный и по хеш-коду, и по equals()) — добавляем этот элемент в конец
  связного
  списка (или в TreeMap)

2) Поиск элемента (get)

+ Вычисляется хэш-код ключа, который преобразуется в индекс массива.
+ В указанном бакете ищется ключ, используя метод equals().
    + Если ключ найден, возвращается значение.
    + Если ключ отсутствует, возвращается null.

3) Удаление элемента (remove)

+ Вычисляется индекс бакета для удаления. Поиск ключа с помощью метода equals()

+ Если элемент найден:
    + Удаляется узел.
    + Ссылки обновляются (если использовался связный список).

### Какова роль equals() и hashCode() в HashMap?

hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке
корзины и искомого ключа.

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизии в Map возникают, когда несколько различных ключей имеют один и тот же хеш-код. В таких ситуациях разные ключи
оказываются в одном и том же "бакете" в хеш-таблице.

### Почему возникают коллизии?

Когда вы добавляете ключ в HashMap, Java использует метод hashCode() для вычисления хеш-кода этого ключа. Хеш-код — это
число, которое указывает на определённый "бакет" в хеш-таблице, где должен храниться этот ключ. Однако:

+ Хеш-код имеет ограниченный диапазон значений.
+ Количество возможных ключей практически не ограничено.
+ В результате разные ключи могут иметь одинаковые хеш-коды, что приводит к коллизии.

Бакеты (buckets) в HashMap — это элементы внутреннего массива, который используется для хранения данных. Каждый бакет
может содержать одну или несколько пар "ключ-значение".

### Как борятся с коллизиями в HashMap?

+ Цепочки (Chaining):
  Если два ключа попадают в один и тот же "бакет", HashMap создаёт связный список в этом бакете.
  Новые элементы с тем же хеш-кодом добавляются в этот список.
  При доступе к элементам с коллизиями HashMap последовательно проверяет каждый элемент в списке, пока не найдёт нужный
  ключ.
+ Красно-чёрные деревья (с Java 8):Если количество элементов в одном "бакете" (цепочке) превышает определённый порог (
  по умолчанию 8), HashMap начинает использовать красно-чёрное дерево вместо связного списка.
  Это позволяет улучшить производительность поиска, вставки и удаления с O(n) до O(log n) в случае большого количества
  коллизий.
+ Качественная реализация метода hashCode():
  Хороший hashCode() должен распределять ключи равномерно по всем возможным бакетам.
  Избегайте тривиальных реализаций (например, всегда возвращать одно и то же значение).
  Используйте стандартные подходы для вычисления hashCode():
  Для числовых типов: используйте прямые числовые операции.
  Для объектов: комбинируйте hashCode() всех полей, используя простые арифметические операции (например, умножение на
  простое число).

```java

@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (field1 != null ? field1.hashCode() : 0);
    result = 31 * result + (field2 != null ? field2.hashCode() : 0);
    return result;
}
```

+ Правильная реализация метода equals():
  Ключи в HashMap сравниваются не только по хеш-коду, но и с помощью метода equals().
  Если два ключа имеют одинаковый хеш-код, HashMap использует equals() для окончательной проверки их равенства.
  Убедитесь, что equals() корректно сравнивает все важные поля.
+ Использование достаточного размера таблицы:
  Если таблица слишком мала, вероятность коллизий возрастает.
  HashMap автоматически увеличивает размер таблицы при превышении определённой заполненности (по умолчанию это 0.75 от
  общего размера).
  Чтобы уменьшить коллизии, можно задать начальный размер HashMap, если известно, что она будет хранить много элементов.
+ Использование альтернативных структур данных:
  В некоторых случаях HashMap может не подходить, если коллизий слишком много или важно обеспечить упорядоченность
  ключей.
  Рассмотрите возможность использования:
  TreeMap — хранит элементы отсортированными по ключам.
  LinkedHashMap — сохраняет порядок вставки ключей.
  ConcurrentHashMap — потокобезопасная альтернатива HashMap, оптимизированная для многопоточности.

[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите о методах keySet и entrySet? Что такое Entry?

Интерфейс `Map` в Java предоставляет два ключевых метода для работы с ключами и парами ключ-значение: `keySet()` и `entrySet()`.

1. Метод `keySet()`:

+ Возвращает: `Set` объектов, которые представляют ключи всех записей в `Map`.
+ Использование: Используется, когда нужно получить доступ к ключам `Map` и выполнить операции, не связанные со значениями.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<String> keys = ages.keySet();
System.out.println("Keys: " + keys); // Keys: [Bob, Alice, Charlie]

for (String key : keys) {
    System.out.println(key);
}
//Bob
//Alice
//Charlie

```

2. Метод `entrySet()`:

+ Возвращает: `Set` объектов типа `Map.Entry`, который представляет собой пару ключ-значение.
+ Использование: Используется, когда нужно получить доступ как к ключам, так и к значениям `Map` одновременно.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<Map.Entry<String, Integer>> entries = ages.entrySet();
System.out.println("Entries: " + entries); //Entries: [Bob=30, Alice=25, Charlie=28]

for (Map.Entry<String, Integer> entry : entries) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
//Key: Bob, Value: 30
//Key: Alice, Value: 25
//Key: Charlie, Value: 28
```

Ключевые моменты:

+ `Set` гарантирует, что ключи (или пары ключ-значение) не будут дублироваться.
+ Методы `keySet()` и `entrySet()` возвращают неизменяемые представления `Map`. Изменения в полученных `Set` не повлияют на исходную `Map`.
+ Используйте `keySet()` для работы только с ключами.
+ Используйте `entrySet()` для работы с ключами и значениями одновременно.

Преимущества:

+ Предоставляют удобный способ получить доступ к ключам и значениям `Map`.
+ Обеспечивают удобную итерацию по элементам `Map`.
+ Упрощают манипуляции с элементами `Map`.

Дополнительная информация:

+ Интерфейс `Map` также предоставляет метод `values()`, который возвращает `Collection` всех значений `Map`.
+ Методы `keySet()`, `entrySet()` и `values()` возвращают только представления `Map`, а не её копии.
+ Операции модификации на полученных `Set` или `Collection` могут привести к непредсказуемому поведению.

Entry в `Map` - это пара "ключ-значение". Ключ - это уникальный идентификатор для элемента в `Map`. Он используется для доступа к соответствующему значению. Значение - это фактическая информация, связанная с ключом.

Пример: представьте, что у вас есть `Map`, которая хранит информацию о студентах. Ключом может быть номер студенческого билета, а значением - имя студента.

```java
Map<Integer, String> студенты = new HashMap<>();

студенты.put(12345, "Иван Иванов");
студенты.put(67890, "Мария Петрова");
```

В этом случае, `(12345, "Иван Иванов")` и `(67890, "Мария Петрова")` - это entries в `Map`.

Методы для работы с entries:

+ `entrySet()`: Возвращает набор всех `entries` в `Map`.
+ `containsKey(Object key)`: Проверяет, существует ли ключ в `Map`.
+ `containsValue(Object value)`: Проверяет, существует ли значение в `Map`.
+ `get(Object key)`: Возвращает значение, соответствующее заданному ключу.
+ `put(K key, V value)`: Добавляет или обновляет `entry` в `Map`.
+ `remove(Object key)`: Удаляет `entry` с заданным ключом из `Map`.

Использование `entries`: `еntries` в `Map` используются для хранения и извлечения данных, где для каждой записи есть уникальный ключ, который позволяет быстро и эффективно найти соответствующее значение.

[К оглавлению](#DataStructuresAndAlgorithms)

# Что такое TreeMap?

Класс в Java, который реализует интерфейс `NavigableMap`, который в свою очередь наследуется от `SortedMap`.
Представляет
собой ассоциативный массив, где ключи отсортированы в естественном порядке (или по заданному компаратору). Единственная
коллекция, которая не использует equals() и hashCode(). Под капотом TreeMap использует структуру данных, которая
называется красно-чёрное дерево.

### Сложность операций:

О(log n) (т.к. каждый раз отметается половина)

[К оглавлению](#DataStructuresAndAlgorithms)

# HashMap vs TreeMap

| Критерий           | HashMap                                 | TreeMap                                                                                                  |
|--------------------|-----------------------------------------|----------------------------------------------------------------------------------------------------------|
| Организация данных | Использует хэш-таблицу.                 | Использует красно-чёрное дерево.                                                                         |
| Скорость доступа   | O(1) для операций put/get.              | O(log n) для операций put/get.                                                                           |
| Порядок элементов  | Элементы не упорядочены.                | Элементы упорядочены по ключу.                                                                           |
| Null ключи         | Разрешает один null ключ.               | Разрешает null ключи при передаче в конструктор соответствующего компаратора. По умолчанию не разрешает. |
| Использование      | Для быстрого доступа к данным по ключу. | Для работы с упорядоченными данными.                                                                     |


[К оглавлению](#DataStructuresAndAlgorithms)

# Реализации интерфейса Map. Почему интерфейс Map выделен отдельно?

Интерфейс Map выделен отдельно, так как он не является коллекцией в привычном смысле. Его предназначение — хранить пары
“ключ-значение”, а не просто элементы.

| Реализация        | Особенности                                              |
|-------------------|----------------------------------------------------------|
| HashMap           | Быстрая, неупорядоченная, допускает null ключи.          |
| LinkedHashMap     | Сохраняет порядок вставки элементов.                     |
| TreeMap           | Упорядочена по ключам, основана на красно-чёрном дереве. |
| ConcurrentHashMap | Потокобезопасна, Fail-Safe.                              |
| WeakHashMap       | Использует слабые ссылки на ключи, полезна для кешей.    |


[К оглавлению](#DataStructuresAndAlgorithms)

# Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
HashCode() и equals() взаимосвязаны, используются для определения равенства между объектами.

Сначала вычисляется hashCode() объектов, тк эта операция быстрее equals(). Если hashCode равны, то начинается проверка
на equals.
Если hashCode не равны, то дальнейшая проверка на равенство не проводится.

### Контракт equals + hashcode:

+ Если hashCode() двух объектов возвращает разные значения, то они не могут быть равны
+ Если equals() объектов true, то и хеш-коды должны быть равны
+ Переопределив equals(), всегда переопределять hashCode()
+ Если у объектов одинаковый hashCode(), то они не обязательно equals()
+ При каждом вызове hashCode() для одного и того же объекта должен возвращаться один и тот же хеш-код

### Свойства equals

- Сравниваемые объекты должны быть одного типа (instanceof())
- Рефлексивность. Объект должен быть равен самому себе (x.equals(x) == true)
- Симметричность. если объект a равен объекту b, то b должен быть равен a. (x.equals(y) == true и y.equals(x) == true)
- Транзитивность. если a равен b, а b равен c, то и a должен быть равен c. (x.equals(y) == true и y.equals(z) == true и
  x.equals(z) == true)
- Непротиворечивость. результат сравнения объектов не должен изменяться в течение их жизни.
- Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false

### Свойства hashCode():

+ Согласованность. При каждом вызове hashCode() для одного и того же объекта в рамках одной программы должно
  возвращаться одно и то же значение, если поля объекта, участвующие в расчете хеш-кода, не изменились
+ Равенство и хеш-код. Если два объекта равны по методу equals(), их хеш-коды тоже должны быть равны. Однако обратное не
  обязательно — объекты с одинаковым хеш-кодом могут быть не равны
+ Распределение. Реализация hashCode(), возвращающая разный хеш-код для неравных объектов позволяет увеличить
  эффективность работы с хеш-структурами данных (такими как HashMap или HashSet) за счёт распределения объектов по
  разным корзинам хеш-таблицы

### Что будет, если переопределить equals() не переопределяя hashCode()?

+ Объект, который по equals() равен существующему ключу в HashMap, может не быть найден, если их хеш-коды различаются.
  Это связано с тем, что HashMap сначала использует hashCode() для поиска корзины, а уже потом сравнивает объекты по
  equals().
+ При попытке удалить ключ, который равен другому ключу по equals(), но имеет другой hashCode(), удаление может не
  сработать.

[К оглавлению](#DataStructuresAndAlgorithms)

# Big O

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью. Временная сложность алгоритма – это функция, позволяющая
определить, как быстро увеличивается время работы алгоритма с увеличением объёма данных. Наиболее часто встречающиеся
классы сложности:

+ O(1) – константная сложность (т.е. константное время);
+ О(n) – линейная сложность;
+ О(log(n)) – логарифмическая сложность;
+ O(n*log(n)) – квазилинейная сложность;
+ O(2n) – экспоненциальная сложность;
+ O(n!) – факториальная сложность.

![Временная сложность коллекций.png](../../../resources/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9.png)

1. ArrayList (на основе массива)

- Добавление: в конец — амортизированное O(1). Когда массив заполняется, он увеличивается в размере, что требует O(
  n) времени на копирование всех элементов в новый массив.
- Замена: O(1), так как доступ к элементам по индексу осуществляется за константное время.
- Удаление: O(n), так как после удаления элемента все последующие элементы нужно сдвинуть влево.

2. LinkedList (двусвязный список)

- Добавление: В начало или конец — O(1), поскольку требуется изменить только несколько ссылок. В середину — O(n),
  так как нужно сначала найти позицию (линейный обход).
- Замена: O(n), так как нужно сначала найти элемент.
- Удаление: с начала или конца — O(1). В середине — O(n), так как требуется линейный обход до элемента.

3. HashMap (хэш-таблица)

- Добавление/замена: O(1) в среднем, но O(n) в худшем случае при большом количестве коллизий.
- Удаление: O(1) в среднем, но O(n) в худшем случае (опять же из-за коллизий).

4. TreeMap (на основе красно-черного дерева)

- Добавление/замена: O(log n), так как элементы хранятся упорядоченно, и операция требует поиска правильного места.
- Удаление: O(log n), так как удаление требует перестройки дерева.

### С чем связаны отличия?

- Коллекции используют разные структуры данных, например, массивы, списки, деревья, хэш-таблицы. Это напрямую влияет на
  сложность операций.
- Методы управления памятью: Например, ArrayList использует массивы, которые иногда требуют расширения и копирования,
  что увеличивает сложность операций.
- Необходимость перемещения данных: В ArrayList при удалении требуется перемещать элементы, тогда как в LinkedList
  достаточно изменить ссылки.
- Алгоритмы поиска и вставки: В деревьях и хэш-таблицах используются разные подходы для поиска и вставки, которые
  определяют временные характеристики.

[К оглавлению](#DataStructuresAndAlgorithms)

# Алгоритмы сортировки и их сложность, какая сортировка используется в java

1) Сортировка пузырьком (Bubble Sort): Простой, но неэффективный метод сортировки. В каждом проходе он сравнивает
   соседние
   элементы и меняет их местами, если они в неправильном порядке. Процесс повторяется, пока все элементы не окажутся в
   нужном порядке.

+ В худшем и среднем случае: O(n²)
+ В лучшем случае (если список уже отсортирован): O(n)

2) Сортировка вставками (Insertion Sort): Проходит по списку, вставляя каждый элемент в правильную позицию в уже
   отсортированную часть списка. Эффективен для небольших или почти отсортированных данных.

+ В худшем и среднем случае: O(n²)
+ В лучшем случае (если список уже отсортирован): O(n)

3) Сортировка выбором (Selection Sort): Находит минимальный (или максимальный) элемент в списке и меняет его местами с
   первым элементом. Затем повторяет процесс для оставшейся части списка.

+ В худшем и среднем случае: O(n²)

4) Сортировка слиянием (Merge Sort): Разделяет массив пополам и рекурсивно сортирует каждую половину, затем соединяет их
   обратно в отсортированный массив.

+ В худшем, среднем и лучшем случае: O(n log n)

5) Быстрая сортировка (Quick Sort): Выбирается опорный элемент, массив разделяется на элементы, меньшие и большие
   опорного,
   затем процесс рекурсивно повторяется для каждой из частей.

+ В худшем случае: O(n²) (когда выбор опорного элемента неудачный)
+ В среднем случае: O(n log n)

В java для сортировки используется Timsort, для примитивных типов Dual-Pivot Quick Sort.

+ Dual-Pivot Quick Sort — сортировки, который используется в Java для примитивных
  типов. Он быстрее классического Quick Sort благодаря использованию двух опорных элементов и более эффективному
  разделению массива.(массив делится на 3 части, а у быстрой сортировки на 2)

+ Timsort — это гибридный алгоритм сортировки, который сочетает в себе идеи сортировки вставками (Insertion Sort) и
  сортировки слиянием (Merge Sort).
    + Использует сортировку вставками для небольших подмассивов (так как она эффективна для малых данных).
    + Использует сортировку слиянием для объединения отсортированных подмассивов (так как она эффективна для больших
      данных
      и устойчива).

[К оглавлению](#DataStructuresAndAlgorithms)

# Алгоритм линейного поиска

Линейный поиск — это самый простой способ найти элемент в списке. В этом алгоритме мы начинаем с первого элемента списка
и проверяем каждый элемент по очереди, пока не найдем нужный. Если элемент найден, мы возвращаем его индекс; если мы
прошли весь список, а элемента нет, то возвращаем информацию, что элемент не найден.
Этот алгоритм работает за время O(n), где n — количество элементов в массиве, потому что мы проверяем каждый элемент
один за другим.

### Реализация

+ Мы проходим по каждому элементу в массиве (или списке).
+ Для каждого элемента сравниваем его с тем, который ищем.
+ Если находим нужный элемент, возвращаем его индекс.
+ Если элемент не найден, возвращаем -1 или другое значение, означающее, что элемент не найден.

```java
public class LinearSearch {
    // Метод для выполнения линейного поиска
    public static int linearSearch(int[] arr, int target) {
        // Проходим по каждому элементу массива
        for (int i = 0; i < arr.length; i++) {
            // Если нашли нужный элемент
            if (arr[i] == target) {
                return i;  // Возвращаем индекс найденного элемента
            }
        }
        return -1;  // Если не нашли элемент, возвращаем -1
    }
}

```

[К оглавлению](#DataStructuresAndAlgorithms)

# Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска элемента в отсортированном списке. Вместо того, чтобы проверять каждый
элемент по очереди, как в линейном поиске, бинарный поиск «делит» список пополам на каждом шаге, сокращая количество
элементов, среди которых нужно искать, вдвое. Это позволяет значительно ускорить поиск, особенно в больших списках.
Массив должен быть отсортированным. Без этого бинарный поиск не будет работать корректно. Время работы бинарного
поиска — O(log n), где n — количество элементов в списке.

### Реализация:

+ Сначала мы определяем элемент в середине списка.
+ Если этот элемент — искомый, мы нашли его и возвращаем индекс.
+ Если искомое значение меньше текущего элемента, мы будем искать в левой половине списка.
+ Если искомое значение больше текущего элемента, мы будем искать в правой половине списка.
+ Мы продолжаем делить список пополам, пока не найдем искомый элемент или не определим, что его нет в списке.

```java
public class BinarySearch {
    // Метод бинарного поиска
    public static int binarySearch(int[] arr, int target) {
        for (int left = 0, right = arr.length - 1; left <= right; ) {
            int middle = (left + right) / 2;  // Индекс середины

            // Если найден элемент
            if (arr[middle] == target) {
                return middle;  // Возвращаем индекс элемента
            }
            // Если искомое число меньше среднего элемента
            else if (arr[middle] > target) {
                right = middle - 1;  // Ищем в левой половине
            }
            // Если искомое число больше среднего элемента
            else {
                left = middle + 1;  // Ищем в правой половине
            }
        }
        return -1;  // Если элемент не найден
    }
}

```

[К оглавлению](#DataStructuresAndAlgorithms)

# Как с собой связаны Iterable и foreach?

1. Iterable — это интерфейс в Java, который определяет метод iterator(). Он позволяет объекту предоставлять итератор для перебора его элементов.
2. foreach — синтаксический сахар, который компилируется в использование итератора, работает только с объектами, реализующими интерфейс Iterable, что обеспечивает возможность итерации.

```java
List<String> list = List.of("a", "b", "c");

// Использование foreach
for (String item : list) {
    System.out.println(item);
}

// Как это работает под капотом:
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    System.out.println(item);
}
```

[К оглавлению](#DataStructuresAndAlgorithms)

# HashTable - что это такое?

HashTable — это реализация структуры данных хэш-таблицы в Java, которая позволяет хранить пары “ключ-значение”. Она
принадлежит пакету java.util и была введена в ранних версиях Java.

1. Потокобезопасность: Методы синхронизированы, поэтому она подходит для многопоточных сред. Однако это снижает
   производительность по сравнению с несинхронизированными коллекциями, такими как HashMap.
2. Запрещены null ключи и значения: Попытка использовать null вызовет исключение NullPointerException.
3. Наследие: Считается устаревшим, так как современные альтернативы, такие как ConcurrentHashMap, более эффективны.

[К оглавлению](#DataStructuresAndAlgorithms)

# Arrays.asList() and List.of()

| Метод                    | Arrays.asList()                                                                                         | List.of()                                                                  |
|--------------------------|---------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| Модифицируемость         | Возвращает изменяемый список.                                                                           | Возвращает неизменяемый список (read-only).                                |
| Допустимость null        | Поддерживает элементы null.                                                                             | Не допускает null элементы.                                                |
| Тип возвращаемого списка | java.util.Arrays$ArrayList                                                                              | ImmutableCollections.List                                                  |
| Проблемы                 | При добавлении/удалении элементов выбрасывает UnsupportedOperationException, так как связан с массивом. | Не поддерживает изменения, выбрасывает исключения при попытке модификации. |
| Использование            | Для создания списка из массива с возможностью редактирования элементов.                                 | Для создания небольшой неизменяемой коллекции.                             |

[К оглавлению](#DataStructuresAndAlgorithms)