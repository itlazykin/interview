# Exceptions

[Расскажите про иерархию исключений](#расскажите-про-иерархию-исключений)

[Что такое Error и Exception](#что-такое-error-и-exception)

[Расскажите про обрабатываемые и необрабатываемые исключения](#расскажите-про-обрабатываемые-и-необрабатываемые-исключения)

[О чем говорит ключевое слово throws](#о-чем-говорит-ключевое-слово-throws)

[Как создать собственное («пользовательское») исключение](#как-создать-собственное-пользовательское-исключение)

[Расскажите про механизм обработки исключений в java (Try-catch-finally)](#расскажите-про-механизм-обработки-исключений-в-java-try-catch-finally)

[Возможно ли использование блока try-finally (без catch)](#возможно-ли-использование-блока-try-finally-без-catch)

[Может ли один блок catch отлавливать сразу несколько исключений](#может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)

[Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?](#всегда-ли-выполняется-блок-finally-существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)

[В каком порядке следует обрабатывать исключения в catch блоках?](#в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)

[Что такое механизм try-with-resources](#что-такое-механизм-try-with-resources)

[@SneakyThrows в Lombok](#sneakythrows-в-lombok)

[StackOverflowError vs OutOfMemoryError](#stackoverflowerror-vs-outofmemoryerror)

[Ошибка OutOfMemoryError. Поймать утечку памяти и пофиксить](#ошибка-outofmemoryerror-поймать-утечку-памяти-и-пофиксить)

# Расскажите про иерархию исключений

![exceptions_hierarchy_1.png](../../../resources/exceptions_hierarchy_1.png)

[К оглавлению](#Exceptions)

# Что такое Error и Exception

+ Error - Связаны с проблемами уровня JVM 
+ Exception - Являются результатом проблем в программе

[К оглавлению](#Exceptions)

# Расскажите про обрабатываемые и необрабатываемые исключения

+ Checked - Exception. Должны обрабатываться блоком catch, или описываться в сигнатуре метода (IOException)

+ Unchecked - Ошибки Error, а так же исключения времени выполнения (RuntimeException) и его наследниками. Могут не
обрабатываться блоком catch и не быть описаны в сигнатуре метода

[К оглавлению](#Exceptions)

# О чем говорит ключевое слово throws

Метод потенциально может выбросить исключение с указанным типом (элемент контракта метода). Передаёт обработку исключения вышестоящему методу

[К оглавлению](#Exceptions)

# Как создать собственное («пользовательское») исключение

Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException) и переопределить методы

[К оглавлению](#Exceptions)

# Расскажите про механизм обработки исключений в java (Try-catch-finally)

+ Try - блок в котором может возникнуть исключение 
+ Catch - блок в котором мы ловим исключение и пишем логику его обработки 
+ Finally - блок, который обязательно отработает

[К оглавлению](#Exceptions)

# Возможно ли использование блока try-finally (без catch)

Да, в таком случае после try выполнится finally

[К оглавлению](#Exceptions)

# Может ли один блок catch отлавливать сразу несколько исключений

Да

[К оглавлению](#Exceptions)

# Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?

Да, кроме случаев завершения программы или JVM. Finally может не выполниться в случае если в блоке try вызывает System.exit(0)

[К оглавлению](#Exceptions)

# В каком порядке следует обрабатывать исключения в catch блоках?

От наследника к родителю. Иначе мы не дойдем до наследника

[К оглавлению](#Exceptions)

# Что такое механизм try-with-resources

Это механизм, который автоматически закрывает ресурс. В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс AutoClosable или Closable (Scanner, например)

[К оглавлению](#Exceptions)

# @SneakyThrows в Lombok

@SneakyThrows — это аннотация Lombok, которая позволяет автоматически обрабатывать исключения, не требуя явного указания
try-catch или объявления throws в методе. Lombok оборачивает вызов в блок, который выбрасывает исключение как
RuntimeException.

````
@SneakyThrows
public void riskyMethod() {
    throw new IOException("Exception example"); // Не нужно объявлять throws IOException
}
````

[К оглавлению](#Exceptions)

# StackOverflowError vs OutOfMemoryError

Оба исключения (StackOverflowError и OutOfMemoryError) относятся к ошибкам времени выполнения (Error), которые указывают
на критические проблемы, связанные с памятью в JVM. Однако у них разные причины и способы возникновения.

`StackOverflowError`

StackOverflowError возникает, когда переполняется стек вызовов (stack memory). Обычно это происходит из-за глубокой или
бесконечной рекурсии, когда метод вызывает сам себя, но нет условия выхода.

### Причины:
+ Бесконечная рекурсия. 
+ Слишком глубокий уровень рекурсивных вызовов. 
+ Очень большие локальные переменные (занимают много места в стеке).

### Как избежать?

+ Добавлять условие выхода из рекурсии. 
+ Ограничивать глубину рекурсивных вызовов. 
+ Использовать итерацию вместо рекурсии, если возможно. 
+ Увеличить размер стека с помощью -Xss (не рекомендуется без необходимости).

`OutOfMemoryError`

OutOfMemoryError возникает, когда JVM не может выделить достаточно памяти в куче (Heap) для создания нового объекта.

### Возможные причины:

+ Создание очень большого массива или объекта. 
+ Утечки памяти (неочищенные ссылки на объекты). 
+ Чрезмерное создание объектов без их удаления. 
+ Ограничение памяти JVM (по умолчанию) — например, -Xmx256m.

### Как избежать?

+ Оптимизировать управление памятью (использовать WeakReference, SoftReference). 
+ Удалять ненужные объекты (list.clear(), null-ссылки). 
+ Использовать профилировщики памяти (VisualVM, MAT). 
+ Увеличить Heap Size (-Xmx1024m).

### Как вызвать StackOverflowError?

````
Простой пример бесконечной рекурсии:

public class StackOverflowExample {
    public static void recursiveMethod() {
        recursiveMethod(); // Метод вызывает сам себя бесконечно
}

    public static void main(String[] args) {
        recursiveMethod();
    }
}

Результат:

Exception in thread "main" java.lang.StackOverflowError
````

### Как вызвать OutOfMemoryError?

````
Пример создания слишком большого массива:

public class OOMExample {
    public static void main(String[] args) {
        int[] bigArray = new int[Integer.MAX_VALUE]; // Запрос огромного массива
    }
}

Результат:

Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
````

````
Пример утечки памяти:

import java.util.ArrayList;
import java.util.List;

public class MemoryLeakExample {
    public static void main(String[] args) {
        List<int[]> list = new ArrayList<>();
        while (true) {
            list.add(new int[1000000]); // Создаем массивы без их удаления
        }
    }
}
````

[К оглавлению](#Exceptions)

# Ошибка OutOfMemoryError. Поймать утечку памяти и пофиксить

Ошибка OutOfMemoryError возникает, когда JVM не может выделить достаточно памяти для выполнения программы. Это может
быть связано с утечками памяти, неправильной конфигурацией или большим объемом данных. Вот пошаговый процесс, как
выявить и устранить причину:

+ Соберите дамп памяти. 
+ Найдите источники утечки. 
+ Исправьте типичные проблемы:
  + Неосвобожденные ресурсы.  
  + Переполненные коллекции. 
  + Статические ссылки.
  + Неотписавшиеся слушатели.
+ Убедитесь, что память используется корректно.

[К оглавлению](#Exceptions)