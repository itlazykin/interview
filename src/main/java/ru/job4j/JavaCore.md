## JavaCore

[К какому типу языка программирования относится Java? Что такое исходный код? Что такое байт-код?](#к-какому-типу-языка-программирования-относится-java-что-такое-исходный-код-что-такое-байт-код)

[3. Какие типы ссылок существуют в Java?](#3-какие-типы-ссылок-существуют-в-java)

[4. Какой класс называют Immutable?](#4-какой-класс-называют-immutable)

[5. Основная идея языка](#5-основная-идея-языка)

[6. За счет чего обеспечена кроссплатформенность?](#6-за-счет-чего-обеспечена-кроссплатформенность)

[7. Плюсы и минусы Java?](#7-плюсы-и-минусы-java)

[8. JVM, JRE, JDK, JIT](#8-jvm-jre-jdk-jit)

[9. Что такое байт-код?](#9-что-такое-байт-код)

[10. Что такое сборщик мусора (garbage collector)? Когда использовать другие GC? Как работает GC? Какие виды GC знаешь?](#10-что-такое-сборщик-мусора-garbage-collector-когда-использовать-другие-gc-как-работает-gc-какие-виды-gc-знаешь)

[11. Области памяти Java](#11-области-памяти-java)

[12. Типы данных в Java](#12-типы-данных-в-java)

[13. Что такое класс-обертка?](#13-что-такое-класс-обертка)

[14. Автоупаковка и автораспаковка](#14-автоупаковка-и-автораспаковка)

[15. Строки/String в Java? Из чего состоит? Нюансы?](#15-строкиstring-в-java-из-чего-состоит-нюансы)

[16. Что такое пул строк/String pool? метод intern()](#16-что-такое-пул-строкstring-pool-метод-intern)

[17. Почему не рекомендуется изменять строки в цикле?](#17-почему-не-рекомендуется-изменять-строки-в-цикле)

[18. Разница между String, StringBuffer, StringBuilder](#18-разница-между-string-stringbuffer-stringbuilder)

[19. Каким образом переменные передаются в методы — по значению или по ссылке?](#19-каким-образом-переменные-передаются-в-методы--по-значению-или-по-ссылке)

[20. Что такое enum?](#20-что-такое-enum)

[21. Что такое конструктор?](#21-что-такое-конструктор)

[22. Какие есть модификаторы доступа? Какие применимы к классам?](#22-какие-есть-модификаторы-доступа-какие-применимы-к-классам)

[23. Что означает static?](#23-что-означает-static)

[24. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?](#24-можно-ли-сузить-уровень-доступа-или-тип-возвращаемого-значения-при-переопределении-метода)

[25. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т.п.)?](#25-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы-throws-и-тп)

[26. Что означает модификатор final? К чему он может быть применим?](#26-что-означает-модификатор-final-к-чему-он-может-быть-применим)

[27. Что такое абстрактные классы?](#27-что-такое-абстрактные-классы)

[28. Что такое интерфейсы?](#28-что-такое-интерфейсы)

[29. Отличия интерфейса от абстрактных классов?](#29-отличия-интерфейса-от-абстрактных-классов)

[30. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#30-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов)

[31. Зачем нужны и какие бывают блоки инициализации?](#31-зачем-нужны-и-какие-бывают-блоки-инициализации)

[32. Для чего в Java используются статические блоки инициализации?](#32-для-чего-в-java-используются-статические-блоки-инициализации)

[33. Класс Object и его методы? Метод finalize()](#33-класс-object-и-его-методы-метод-finalize)

[34. Что такое сериализация и для чего она нужна?](#34-что-такое-сериализация-и-для-чего-она-нужна)

[35. Разница между версиями Java](#35-разница-между-версиями-java)

[36. Может ли абстрактный класс быть final?](#36-может-ли-абстрактный-класс-быть-final)

[37. Integer pool](#37-integer-pool)

[38. Какие виды загрузчиков классов ты знаешь?](#38-какие-виды-загрузчиков-классов-ты-знаешь)

[39. Record-ы c Java 17. Для чего и зачем?](#39-record-ы-c-java-17-для-чего-и-зачем)

[40. Что такое Анонимный класс](#40-что-такое-анонимный-класс)

[41. Расскажи что делает JIT компилятор](#41-расскажи-что-делает-jit-компилятор)

[42. Расскажи про прогрев JVM](#42-расскажи-про-прогрев-jvm)

[43. break vs continue в цикле](#43-break-vs-continue-в-цикле)

[44. Что такое аннотация? Зачем нужна? Как создать свою аннотацию?](#44-что-такое-аннотация-зачем-нужна-как-создать-свою-аннотацию)

[45. Переопределение и перегрузка методов](#45-переопределение-и-перегрузка-методов)

[46. Что такое Optional? В чем разница между методами orElse и orElseGet?](#46-что-такое-optional-в-чем-разница-между-методами-orelse-и-orelseget)

# К какому типу языка программирования относится Java? Что такое исходный код? Что такое байт-код?

+ Java, является высокоуровневым языком программирования, использует исходный код, который компилируется в байт-код для
  достижения платформенной независимости и эффективного выполнения программ.
+ Исходный код — это текст программы, написанный программистом на языке программирования высокого уровня, таком как
  Java. Исходный код представляет собой человеко-читаемый набор инструкций, которые описывают, что должна делать
  программа.
+ Байт-код — это промежуточный код, который генерируется компилятором Java (javac) после компиляции исходного кода.
  Байт-код не зависит от платформы и может быть выполнен на любой системе, где установлена соответствующая Java Virtual
  Machine (JVM). Байт-код не является человеко-читаемым и представляет собой набор инструкций, которые JVM
  интерпретирует или компилирует в машинный код в процессе выполнения программы.

[К оглавлению](#JavaCore)

# 3. Какие типы ссылок существуют в Java?

+ Сильная ссылка. Обычная ссылка, которая повсеместно используется (Object obj = new Object()). Объект не будет удален
сборщиком мусора, пока на него есть хотя бы одна сильная ссылка 
+ Мягкая ссылка. Используются для кеширования. Объект, на который ссылается мягкая ссылка, будет удален сборщиком мусора
только при нехватке памяти (SoftReference<MyObject> softRef = new SoftReference<>(new MyObject()))
+ Слабая ссылка. Объект, на который ссылается слабая ссылка, может быть удален сборщиком мусора при следующей проверке,
даже если на него есть слабые ссылки (WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject()))
+ Фантомная ссылка. Используется для отслеживания, когда объект был удален из памяти. Фантомная ссылка не позволяет
получить доступ к объекту напрямую, она только сигнализирует, что объект скоро будет удален (PhantomReference<MyObject>
phantomRef = new PhantomReference<>(new MyObject(), referenceQueue))

[К оглавлению](#JavaCore)

# 4. Какой класс называют Immutable?

Иммутабельный класс - класс, экземпляры которого не могут быть изменены после создания. Принципы создания:

+ Поля private final 
+ Не предоставляйте методы, которые изменяют состояние объекта (никаких setter-ов)
+ Гарантируйте невозможность расширения класса (класс делаем final)
+ Все поля устанавливаются через конструктор 
+ Обеспечьте монопольный доступ ко всем изменяемым компонентам. Если класс имеет любые поля, ссылающиеся на изменяемые 
объекты, убедитесь, что клиенты класса не смогут получить ссылки на эти объекты (защитные копии (defensive copies), 
использование иммутабельных объектов).

[К оглавлению](#JavaCore)

# 5. Основная идея языка

Написано однажды - работает везде

[К оглавлению](#JavaCore)

# 6. За счет чего обеспечена кроссплатформенность?

За счет создания виртуальной машины Java. Это что-то вроде прослойки между ОС и Java программой

[К оглавлению](#JavaCore)

# 7. Плюсы и минусы Java?

`Плюсы`:

+ Объектно-ориентированное программирование. Структура данных становится объектом, которым можно управлять, создавать
  отношения между различными объектами.

+ Стандарт для корпоративных вычислительных систем. Корпоративные приложения — главное преимущество Java с 90-х годов,
  когда организации начали искать надежные инструменты программирования не на C.

+ Независимость от платформы. Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на
  любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции
  между кодом и оборудованием.

+ Стабильность и сообщество. Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса
  StackOverflow 2018 используют Java.

`Минусы`:

+ Платное коммерческое использование (с 2019)
+ Надо много чего изучить, прежде чем что-то написать.

[К оглавлению](#JavaCore)

# 8. JVM, JRE, JDK, JIT

+ JVM - Виртуальная машина Java, которая исполняет байт-код
+ JRE - Среда выполнения Java. Включает в себя JVM и стандартные библиотеки классов
  + java.lang - String, System, Object
  + java.io - InputStream, OutputStream
  + java.util - коллекции (List, Set, Map)
+ JDK - Набор инструментов для разработки. Включает в себя JRE, компилятор и другие утилиты 
+ JIT - компиляция байт-кода в машинный во время выполнения программы

[К оглавлению](#JavaCore)

# 9. Что такое байт-код?

Набор инструкций исполняемый виртуальной машиной Java

[К оглавлению](#JavaCore)

# 10. Что такое сборщик мусора (garbage collector)? Когда использовать другие GC? Как работает GC? Какие виды GC знаешь?

В Java используется автоматическое управление памятью. Программист выделяет память, а за освобождение отвечает JVM.
Когда программа больше не ссылается на объект (прямые или косвенные ссылки), то объект удаляется, а память
переиспользуется. GC – часть JVM, прикладная программа, которая занимается очищением памяти. Он выполняет две задачи:
+ поиск
+ очистка мусора.

### Вызов сборщика мусора сейчас?

`system.gc()`

### Разница между GC в разных версиях Java

| Версия Java | GC по умолчанию | Примечания                                                 |
|-------------|-----------------|------------------------------------------------------------|
| Java 8      | Parallel GC     | Оптимизирован для пропускной способности                   |
| Java 9      | G1              | G1 стал сборщиком по умолчанию, заменив Parallel GC        |
| Java 10	    | G1              | Улучшения в G1, включая параллельную полную сборку мусора. |
| Java 11	    | G1              | Введены ZGC и Shenandoah (экспериментальные)               |
| Java 12	    | G1              | Улучшения в G1, включая возврат неиспользуемой памяти.     |
| Java 13	    | G1              | Улучшения в ZGC и Shenandoah                               |
| Java 14	    | G1              | ZGC и Shenandoah стали стабильными                         |
| Java 15	    | G1              | ZGC стал кроссплатформенным                                |
| Java 16	    | G1              | Улучшения в ZGC и Shenandoah                               |
| Java 17	    | G1              | CMS окончательно удален                                    |
| Java 21	    | G1              | Введен Generational ZGC, улучшения в G1, ZGC и Shenandoah  |

### Когда использовать другие GC?

+ ZGC: Для приложений с огромными кучами (терабайты) и требованиями к минимальным паузам (менее 10 мс). 
+ Shenandoah: Для приложений с низкими задержками и большими кучами. 
+ Parallel GC: Для приложений, где важна пропускная способность, а не низкие задержки. 
+ Serial GC: Для однопоточных приложений или приложений с небольшими кучами.

### Как работает GC?

1)Поиск недостижимых объектов: Проверяет, есть ли ссылки на объект.

2)Очистка: Если объект недостижим, его память освобождается.

3)Обновление памяти: Освобождённая память становится доступной для новых объектов.

`Основные алгоритмы GC`:

+ Mark-and-Sweep: Отмечает используемые объекты и удаляет неиспользуемые. 
+ Generational GC: Разделяет память на молодое, старшее и постоянное поколение для оптимизации работы.

### Какие виды GC знаешь?

+ Serial GC: Подходит для небольших приложений (однопоточный). 
+ Parallel GC: Использует несколько потоков, подходящий для многопоточных приложений. 
+ CMS (Concurrent Mark-Sweep): Быстрый сбор мусора, минимизирует паузы. 
+ G1 GC (Garbage First): Балансирует между производительностью и паузами. 
+ ZGC: Для приложений с низкими паузами, работающими с большим объёмом памяти. 
+ Shenandoah GC: Минимизирует паузы сборщика мусора.

[К оглавлению](#JavaCore)

# 11. Области памяти Java

`Stack` - это область хранения данных. Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который
содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает
использоваться, тем самым предоставляя доступ для следующего метода. Стек в Java работает по схеме LIFO (Последний
зашел - Первый вышел)

`Heap` (куча) используется для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче.
Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

| Область памяти      | Описание                                                                                          |
|---------------------|---------------------------------------------------------------------------------------------------|
| Heap (Куча)         | Для динамического распределения объектов и классов. Управляется сборщиком мусора                  |
| Stack (Стек)        | Хранит локальные переменные и вызовы методов. Каждый поток имеет свой собственный стек            |
| Method Area         | Хранит информацию о классах (имена классов, методы, переменные). Общая для всех потоков           |
| PC Register         | Хранит адрес текущей инструкции, выполняемой потоком. Каждый поток имеет свой собственный регистр |
| Native Method Stack | Для выполнения нативных методов (написанных на других языках)                                     |
| Code Cache          | Хранит скомпилированный JIT-код для повышения производительности                                  |
| Metaspace           | Для хранения метаданных классов. Заменяет Permanent Generation (PermGen)                          |

### В чём разница между Stack и Heap?

+ Куча больше стека 
+ Стек хранит примитивы и ссылки на объекты, а куча хранит все созданные объекты 
+ Память стека существует пока выполняется текущий метод, а куча существует пока работает приложение 
+ Стек быстрее кучи

### В какой области памяти содержатся типы данных?

| Тип данных         | Расположение                                            |
|--------------------|---------------------------------------------------------|
| Примитивные типы   | В стеке (локальные переменные) или куче (поля объекта). |
| Объекты            | В куче                                                  |
| Ссылки на объекты  | В стеке                                                 |
| Метаданные классов | В Metaspace                                             |

[К оглавлению](#JavaCore)
 
# 12. Типы данных в Java

В Java есть примитивные и ссылочные типы данных.

### Примитивные типы данных:

+ byte (0) (8 бит)
+ short (0) (16 бит)
+ int (0) (32 бит)
+ long (0L) (64 бит)
+ float (0.0f) (32 бит)
+ double (0.0d) (64 бит)
+ char (\u0000) (16 бит)
+ boolean (false) 

[К оглавлению](#JavaCore)

# 13. Что такое класс-обертка?

Обертка - специальный класс, который хранит внутри себя значения примитива. Обертки являются Immutable

[К оглавлению](#JavaCore)

# 14. Автоупаковка и автораспаковка

+ Автоупаковка - примитивный тип ⇒ объектный класс 
+ Автораспаковка - объектный класс ⇒ примитивный тип

[К оглавлению](#JavaCore)

# 15. Строки/String в Java? Из чего состоит? Нюансы?

Класс String представляет строковый набор символов.
Класс String - immutable из-за модификатора final и отсутствия сеттера. При редактировании строк будет создаваться новая строка

[К оглавлению](#JavaCore)

# 16. Что такое пул строк/String pool? метод intern()

Пул строк — это особая область кучи (heap), где хранятся объекты строк. Служит в первую очередь для оптимизации работы
со строковыми литералами. При объявлении литерала (строки в двойных кавычках) в пуле происходит поиск этой строки:

+ Если такой строки в пуле нет ⇒ создается строка, возвращается ссылка
+ Если есть ⇒ возвращается ссылка найденной строки

`Строки, созданные с помощью new String() не помещаются в пул строк и хранятся в куче как остальные объекты`.

### Что делает метод intern() в классе String?

Помещает строку в пул строк

[К оглавлению](#JavaCore)

# 17. Почему не рекомендуется изменять строки в цикле?

Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать
новую строку. Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со
строками – StringBuffer и StringBuilder.

[К оглавлению](#JavaCore)

# 18. Разница между String, StringBuffer, StringBuilder

+ String - неизменяемый, потокобезопасный 
+ StringBuffer - изменяемый, потокобезопасный 
+ StringBuilder - изменяемый, потокоНЕбезопасный

[К оглавлению](#JavaCore)

# 19. Каким образом переменные передаются в методы — по значению или по ссылке?

По значению. Всегда

[К оглавлению](#JavaCore)

# 20. Что такое enum?

Enum - набор логически связанных констант. Нужны для ограничения области допустимых значений (времена года, дни недели)

[К оглавлению](#JavaCore)

# 21. Что такое конструктор?

Конструкторы в Java представляют собой специальный блок кода, похожий на метод, предназначенный для инициализации полей
объекта при его создании. Он вызывается всегда, когда создается новый экземпляр класса.

### Конструктор по умолчанию

Если у класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый “конструктор по умолчанию”

### Для чего нужны приватные/private конструкторы?

Приватный конструктор запрещает создание экземпляра класса вне методов самого класса. Нужен для реализации паттернов singleton

```java
public class Singleton {
    // Статическое поле для хранения единственного экземпляра класса
    private static Singleton instance;

    // Приватный конструктор, предотвращающий создание экземпляров извне
    private Singleton() {}

    // Публичный метод для доступа к единственному экземпляру класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами?

+ Конструктор по умолчанию. Отсутствуют какие-либо параметры 
+ Конструктор копирования. Принимает в качестве аргумента уже существующий объект класса для последующего создания его клона 
+ Конструктор с параметрами имеет в своей сигнатуре аргументы

[К оглавлению](#JavaCore)

# 22. Какие есть модификаторы доступа? Какие применимы к классам?

+ private. Доступ только из класса, в котором объявлен 
+ default. Переменная доступна для любого другого класса в том же пакете 
+ protected. Переменная доступна всем классам внутри пакета, а так же всем классам-наследникам вне пакета 
+ public. Доступ к компоненту из любой точки программы

[К оглавлению](#JavaCore)

# 23. Что означает static?

+ static переменная - переменная, принадлежащая классу, а не объекту 
+ static класс - вложенный класс, который может обращаться только к статическим полям класса-обертки 
+ static метод - метод, принадлежащий классу, а не объекту. Статические методы обращаются только к другим статическим методам и переменным

### Может ли статический метод быть переопределен?

Нельзя переопределять статические методы. Если объявить такой же метод в классе-наследнике, то мы лишь «спрячем» метод суперкласса вместо переопределения. Это называется сокрытие методов.

Прим. Перегружать можно, переопределять нет. В случае со статическими методами это не переопределение (overriding), а сокрытие (hiding).

### Могут ли нестатические методы перегружать статические?

Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

### Могут ли классы быть статическими?

Да, вложенные классы

[К оглавлению](#JavaCore)

# 24. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?

Можно расширить модификатор доступа и сузить тип возвращаемого значения (если они совместимы)

[К оглавлению](#JavaCore)

# 25. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и т.п.)?

+ В сигнатуре менять ничего нельзя. 
+ Можно расширить уровень доступа. 
+ Можно сузить тип возвращаемого значения. 
+ Можно не указывать исключения, которые были объявлены в родительском классе. 
+ Можно добавить новые исключения, которые являются наследниками родительского, либо те, что наследуются от RuntimeException

[К оглавлению](#JavaCore)

# 26. Что означает модификатор final? К чему он может быть применим?

+ final у класса. Запрещает наследование 
+ final у метода. Запрещает переопределять данный метод в наследниках класса 
+ final у примитива. Запрещает изменение значения после присвоения 
+ final у ссылочной переменной. Запрещает изменение ссылки на объект 
+ final у массива. Запрещает изменение ссылки на массив (но можно менять элементы внутри)

[К оглавлению](#JavaCore)

# 27. Что такое абстрактные классы?

Абстрактным классом называется класс, у которого не может быть экземпляров. Может содержать абстрактные методы. Наследниками абстрактного класса могут быть другие абстрактные классы и обычные классы

### Может ли быть абстрактный класс без абстрактных методов?

Да, может

### Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?

Да, могут, если они нужны для наследников

[К оглавлению](#JavaCore)

# 28. Что такое интерфейсы?

Интерфейс — это особый абстрактный тип, описывающий поведение (контракт), которое классы должны реализовать

+ Методы интерфейса - public abstract 
+ Поля - public static final

### Какие модификаторы по умолчанию/по дефолту имеют поля и методы интерфейсов?

Default методы - это методы в интерфейсе, которые имеют тело и помечены default. Классы, реализующие такой интерфейс могут не переопределять метод и использовать код из интерфейса.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.

По умолчанию все методы в интерфейсе фактически имеют модификатор public. Однако начиная с Java 9 мы также можем определять в интерфейсе методы с модификатором private. Они могут быть статическими и нестатическими, но обязаны иметь реализацию (т.е. тело метода).

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.

### Может ли один интерфейс наследоваться от другого? От двух других?

Да

### Зачем нужны интерфейсы маркеры?

Интерфейсы-маркеры (marker interfaces) — это интерфейсы без методов, используемые для предоставления метаинформации о классе. Примеры:

+ Serializable — сообщает, что объект может быть сериализован.
+ Cloneable — разрешает создание копий объекта через clone().

### Плюсы и минусы дефолтных методов

`default-методы` позволяют добавлять реализацию методов в интерфейсы без необходимости изменять существующие реализации классов

```java
interface Animal {
    default void makeSound() {
        System.out.println("Some sound...");
    }
}
class Dog implements Animal {}
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Выведет "Some sound..."
    }
}
```

`Плюсы`:
+ Позволяют добавлять новые методы в интерфейсы без ломания существующего кода.  
+ Уменьшают дублирование кода в классах, реализующих интерфейс. 
+ Можно предоставлять базовую реализацию метода.

`Минусы`:
+ Может усложнять иерархию классов, если использовать слишком активно. 
+ Конфликты default-методов, если несколько интерфейсов содержат метод с одинаковой сигнатурой. 
+ Нарушает принцип единственной ответственности (SRP), так как интерфейс начинает содержать логику.

### Плюсы и минусы множественной имплементации

Множественная имплементация означает, что класс может реализовать несколько интерфейсов.

````
Пример:
interface A {
    default void show() {
        System.out.println("A");
    }
}
interface B {
    default void show() {
        System.out.println("B");
    }
}
class C implements A, B {
    @Override
    public void show() {  // Разрешаем конфликт
        A.super.show();
    }
}
````

`Плюсы`:
+ Позволяет избежать проблем, связанных с множественным наследованием (алмазная проблема). 
+ Повторное использование кода через default-методы. 
+ Гибкость — можно комбинировать поведение разных интерфейсов.

`Минусы`: 
+ Конфликты default-методов, если несколько интерфейсов содержат метод с одинаковой сигнатурой.
+ Возможна сложность в отладке и поддержке кода. 
+ Нельзя использовать super для вызова конструктора интерфейса.

[К оглавлению](#JavaCore)

# 29. Отличия интерфейса от абстрактных классов?

+ Абстрактные классы используются, когда есть отношение ‘is a’, а интерфейс может быть реализован классами, вовсе не связанными друг с другом
+ Унаследовать можно только один класс, а реализовать интерфейсов — сколько угодно

| Критерий                          | Абстрактный класс                                                | Интерфейс                                              |
|-----------------------------------|------------------------------------------------------------------|--------------------------------------------------------|
| Когда использовать                | Если есть общая логика, которую наследники могут переопределять	 | Для определения контрактов, которые реализуют классы   |
| Модификаторы доступа по умолчанию | protected, default                                               | Все методы public                                      |
| Наличие конструктора              | Да                                                               | Нет                                                    |
| Наследование/реализация           | Класс может наследовать только один абстрактный класс            | Класс может реализовать несколько интерфейсов          |
| Методы с реализацией              | Может содержать методы с реализацией                             | С Java 8: может содержать default методы с реализацией |

[К оглавлению](#JavaCore)

# 30. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?

1)Статические блоки у родителя

2)Статический блок у наследника

3)Нестатический блок у родителя

4)Конструктор родителя

5)Нестатические блоки у наследника

6)Конструктор наследника

[К оглавлению](#JavaCore)

# 31. Зачем нужны и какие бывают блоки инициализации?

+ `Статический блок инициализации` используется для инициализации статических данных класса. Он выполняется только один
  раз, когда класс загружается в память.
+ `Нестатический блок инициализации`, также известный как блок инициализации экземпляра, используется для инициализации
  переменных экземпляра класса. Он выполняется каждый раз, когда создается новый экземпляр класса.

[К оглавлению](#JavaCore)

# 32. Для чего в Java используются статические блоки инициализации?

Статический блок инициализации используется для инициализации статических данных класса. Он выполняется только один раз, когда класс загружается в память.

[К оглавлению](#JavaCore)

# 33. Класс Object и его методы? Метод finalize()

Object - базовый класс для всех объектов в Java. Любой класс так или иначе наследуется от Object, и, соответственно, наследует его методы (11 штук):

+ equals() - определяет, равен ли один объект другому. 
+ hashCode() - возвращает хэш-код, связанный с вызывающим объектом. 
+ toString() - возвращает символьную строку, описывающую объект. 
+ getClass() - получает класс объекта во время выполнения. 
+ clone() - создает новый объект, не отличающийся от клонируемого. 
+ finalize() - вызывается перед удалением неиспользуемого объекта.

А так же методы для многопоточности:
+ notify() - возобновляет исполнение потока, ожидающего вызывающего объекта. 
+ notifyAll() - возобновляет исполнение всех потоков, ожидающих вызывающего объекта. 
+ wait(), wait(long timeout), wait(long timeout, int nanos) - ожидает другого потока исполнения.

### Метод finalize()

finalize() — это метод в классе Object, который вызывается перед уничтожением объекта сборщиком мусора (GC). Помечен как @Deprecated с Java 9 с возможностью дальнейшего удаления.

```java
class Resource {
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Объект удаляется");
    }
}
public class Main {
    public static void main(String[] args) {
        new Resource();
        System.gc(); // Запрос на сборку мусора
    }
}
```

`Плюсы finalize()`:
+ Можно освободить ресурсы перед удалением объекта.

`Минусы finalize()`:
+ Не гарантируется, что finalize() вызовется своевременно. 
+ Сложно отлаживать, так как GC работает асинхронно. 
+ Медленный — лучше использовать try-with-resources или close().

### Современная альтернатива:

Java 9+: использовать Cleaner или try-with-resources.

[К оглавлению](#JavaCore)

# 34. Что такое сериализация и для чего она нужна?

Сериализация - это процесс сохранения объекта в последовательность байт. Реализована через интерфейс-маркер Serializable. Нужна для компактного сохранения состояния объекта и считывания этого состояния

[К оглавлению](#JavaCore)

# 35. Разница между версиями Java

+ Java 8: Лямбда-выражения, Stream API, Optional API, новый Date and Time API, default методы в интерфейсах. 
+ Java 9: Модульная система (JPMS), улучшения в Stream API и методы Optional.ifPresentOrElse, фабричные методы для коллекций (List.of). 
+ Java 10: Локальная типизация (var), улучшения в GC, API для создания неизменяемых коллекций (List.copyOf, Set.copyOf, Map.copyOf)
+ Java 11: Поддержка var в лямбдах, новый клиент HTTP. 
+ Java 17: Record, sealed классы, улучшения в GC и performance, pattern matching для instanceof. 
+ Java 21: Virtual threads, pattern matching для switch, поддержка sealed-иерархий для record, улучшения в GC

[К оглавлению](#JavaCore)

# 36. Может ли абстрактный класс быть final?

Нет. Ключевое слово final запрещает наследование класса, а абстрактный класс предназначен для наследования

[К оглавлению](#JavaCore)

# 37. Integer pool

Integer Pool — это кеширование объектов типа Integer в диапазоне от -128 до 127 для уменьшения количества создаваемых объектов.

[К оглавлению](#JavaCore)

# 38. Какие виды загрузчиков классов ты знаешь?

+ Bootstrap ClassLoader: Загружает стандартные библиотеки (например, rt.jar). 
+ Extension ClassLoader: Загружает дополнительные библиотеки (ext). 
+ System ClassLoader: Загружает классы из classpath. 
+ Custom ClassLoader: Пользовательские загрузчики классов.

[К оглавлению](#JavaCore)

# 39. Record-ы c Java 17. Для чего и зачем?

Record — это компактная декларация неизменяемого класса, удобная для хранения данных.

`Преимущества`:
+ Автоматическое создание конструктора, getter-ов (методы именуется без префикса get), equals, hashCode, toString.
+ Неизменяемость полей.

````
public record Point(int x, int y) {}
Point p = new Point(1, 2);
System.out.println(p.x()); // 1
````

[К оглавлению](#JavaCore)

# 40. Что такое Анонимный класс

Анонимный класс — это класс без имени, который создаётся и используется в момент создания.

```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello!");
    }
};
```

### Требования к переменным, на которые ссылаемся внутри анонимного класса

Переменные, используемые внутри анонимного класса, должны быть effectively final (не изменяться после инициализации).

[К оглавлению](#JavaCore)

# 41. Расскажи что делает JIT компилятор

JIT (Just-In-Time) компилятор преобразует байт-код в машинный код во время выполнения программы для повышения производительности.

[К оглавлению](#JavaCore)

# 42. Расскажи про прогрев JVM

Прогрев JVM — это процесс оптимизации приложения, когда JIT анализирует исполняемый код и применяет оптимизации, такие как инлайнинг или устранение лишних проверок.

[К оглавлению](#JavaCore)

# 43. break vs continue в цикле

+ break: Завершает выполнение текущего цикла. 
+ continue: Пропускает текущую итерацию цикла и переходит к следующей.

[К оглавлению](#JavaCore)

# 44. Что такое аннотация? Зачем нужна? Как создать свою аннотацию?

Аннотации в Java — это специальный механизм, который позволяет добавлять метаданные к коду (классам, методам, полям и т.
д.). Они не изменяют поведение кода напрямую, но активно используются компилятором, инструментами разработки и
фреймворками.

### Как создать свою аннотацию?

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String value();
    int count() default 1;
}

class Example {
    @MyAnnotation(value = "Hello", count = 3)
    public void test() {
        System.out.println("Метод с аннотацией");
    }
}
```

[К оглавлению](#JavaCore)

# 45. Переопределение и перегрузка методов

`Переопределение методов`

Это изменение поведения метода, унаследованного от родительского класса.

`Правила`:

+ Метод должен иметь точно такое же имя, тип возвращаемого значения и аргументы. 
+ Метод в родительском классе должен быть не private. 
+ Должен происходить в наследуемом классе. 
+ Аннотация @Override рекомендуется (не обязательна, но помогает избежать ошибок).

````
Пример:

class Animal {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Собака лает");
    }
}

Что происходит:

Метод makeSound() переопределён в классе Dog. 
При вызове на объекте типа Dog будет работать именно его версия.
````

`Перегрузка методов (Overloading)`

Это когда в одном классе есть несколько методов с одинаковым именем, но разными параметрами.

`Правила`:

+ Имена методов одинаковые. 
+ Различие — в количестве, типах или порядке аргументов. 
+ Возвращаемый тип может быть любым, но не используется для различия перегрузки.

```java
Пример:

class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}


Что происходит:

Метод add() перегружен — Java понимает, 
какой использовать, в зависимости от аргументов.
```

[К оглавлению](#JavaCore)

# 46. Что такое Optional? В чем разница между методами orElse и orElseGet?

Optional - это класс обертка, основная цель которого предотвратить NullPointerException.

### В чем разница между методами orElse и orElseGet?

+ Метод orElse() принимает конкретное значение, которое будет возвращено, если Optional пуст. Если Optional содержит значение, то возвращается это значение. Если Optional пуст, то возвращается значение, переданное в метод orElse().
+ Метод orElseGet() принимает лямбда-выражение или поставщика (Supplier), который возвращает значение только в том случае, если Optional пуст. Если Optional содержит значение, то возвращается это значение. Если Optional пуст, то вызывается переданный Supplier для получения значения.

Код, переданный в orElseGet() (лямбда или метод), выполняется только при необходимости, то есть только если Optional пуст. Это позволяет избежать ненужных вычислений и улучшить производительность в ситуациях, когда получение значения по умолчанию требует времени или ресурсов.

[К оглавлению](#JavaCore)
