# Solid

[Что такое SOLID (каждая буква)](#что-такое-solid-каждая-буква)

[Какие еще принципы можешь назвать?](#какие-еще-принципы-можешь-назвать)

[Когда мы можем нарушать принципы SOLID](#когда-мы-можем-нарушать-принципы-solid)

[GRASP](#grasp)

# Что такое SOLID (каждая буква)

`SOLID` – это принципы разработки программного обеспечения, следуя которым получаем хороший код, который в дальнейшем
будет хорошо масштабироваться и поддерживаться в рабочем состоянии.

`S` Single Responsibility Principle – принцип единственной ответственности. Каждый класс должен иметь только одну зону
ответственности(т.е. выполнять только 1 задачу)

`O` Open closed Principle – принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для
изменения.

`L` Liskov substitution Principle – принцип подстановки Барбары Лисков.  Подклассы должны дополнять, а не замещать
поведение базового класса.  Стремитесь создавать подклассы таким образом, чтобы их
объекты можно было бы подставлять вместо объектов
базового класса, не ломая при этом функциональности
клиентского кода.

`I` Interface Segregation Principle – это принцип разделения интерфейсов.  Стремитесь к тому, чтобы интерфейсы были достаточно
узкими, чтобы классам не приходилось реализовывать
избыточное поведение.

`D` Dependency Inversion Principle – это принцип инверсии зависимостей. Абстракции НЕ должны зависеть от деталей. Детали
должны зависеть от абстракций. Модули верхнего уровня НЕ должны зависеть от модулей нижнего уровня, НО должны зависеть
от абстракции.

[К оглавлению](#Solid)

# Какие еще принципы можешь назвать?

+ DRY / Don’t Repeat Yourself — Не повторяйся!
+ KISS / Keep It Simple Stupid — Делай это проще
+ YAGNI / You aren't gonna need it — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или
  ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой
  нет непосредственной надобности.

[К оглавлению](#Solid)

# GRASP

GRASP (General Responsibility Assignment Software Patterns) — это набор принципов для распределения обязанностей (responsibilities) между классами и объектами в ООП. Они помогают проектировать систему так, чтобы код был гибким, поддерживаемым и расширяемым

+ Information Expert (Информационный эксперт). Назначайте ответственность тому классу, который обладает максимумом информации для её выполнения. Снижает связанность (классы не лезут в чужие данные)
+ Creator (Создатель). Класс B должен создавать класс A, если: B содержит A, B агрегирует A, B активно использует A. Инкапсуляция логики создания
+ Controller (Контроллер). Используйте отдельный класс для обработки системных событий (например, HTTP-запросов), а не делайте это прямо в UI. Разделение слоёв (UI ≠ бизнес-логика).
+ Low Coupling (Слабая связанность). Минимизируйте зависимости между классами. Систему проще тестировать и модифицировать
+ High Cohesion (Высокая связность). Класс должен решать только одну задачу. Код понятнее и легче рефакторится.
+ Polymorphism (Полиморфизм). Используйте интерфейсы для вариативного поведения. Легко добавлять новые типы.
+ Pure Fabrication (Чистая выдумка). Создавайте искусственные классы (например, сервисы), если это упрощает систему. Соблюдение Single Responsibility.
+ Indirection (Посредник). Добавляйте промежуточный класс для уменьшения связанности. Гибкость (можно заменить реализацию).
+ Protected Variations (Защита от изменений). Изолируйте «нестабильные» части системы за интерфейсами. Минимизация рисков при изменениях.

[К оглавлению](#Solid)