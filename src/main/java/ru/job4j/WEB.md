# WEB

[1. REST](#1-rest)

[2. RESTful и RESTless](#2-restful-и-restless)

[3. REST vs SOAP](#3-rest-vs-soap)

[4. В каких ситуациях допустимо использование RESTless](#4-в-каких-ситуациях-допустимо-использование-restless)

[5. REST vs RPC. Как выбрать что лучше подходит?](#5-rest-vs-rpc-как-выбрать-что-лучше-подходит)

[6. Назовите 6 принципов REST API](#6-назовите-6-принципов-rest-api)

[7. Идемпотентный метод](#7-идемпотентный-метод)

[8. Основные HTTP методы](#8-основные-http-методы)

[9. Статусы ответов](#9-статусы-ответов)

[10. GET vs POST](#10-get-vs-post)

[11. Разница HTTP и HTTPs](#11-разница-http-и-https)

[12. Из чего состоит HTTP запрос](#12-из-чего-состоит-http-запрос)

[13. Какие методы авторизации существуют для HTTP протокола?](#13-какие-методы-авторизации-существуют-для-http-протокола)

[14. Из чего состоит JSON Web Token?](#14-из-чего-состоит-json-web-token)

[15. Какие протоколы уровня приложений?](#15-какие-протоколы-уровня-приложений)

[16. Что такое HTTP?](#16-что-такое-http)

[17. За что отвечают Cookie/куки?](#17-за-что-отвечают-cookieкуки)

[18. Отличия POST, PUT, PATCH](#18-отличия-post-put-patch)

# 1. REST

REST - это архитектурный стиль взаимодействия клиент-серверного WEB-приложения. Клиент-сервер общаются через протокол HTTP (HTTPs), а формат данных - JSON (XML)

[К оглавлению](#WEB)

# 2. RESTful и RESTless

RESTful строго следует принципам REST, используя стандартные методы HTTP и четко структурированные URL, а RESTless нарушает эти принципы, делая взаимодействие менее стандартным и гибким

[К оглавлению](#WEB)

# 3. REST vs SOAP

SOAP и REST – это два разных подхода к разработке API. Подход SOAP отличается высокой степенью структурированности и использует формат данных XML. REST более гибкий и позволяет приложениям обмениваться данными в нескольких форматах.

На данный момент SOAP устаревший подход, использующийся на легаси проектах

[К оглавлению](#WEB)
 
# 4. В каких ситуациях допустимо использование RESTless

Использование RESTless допустимо:

+ В небольшом приложение, где строгие принципы REST не критичны 
+ Если существующая система уже использует другой подход и переделка будет слишком сложной

[К оглавлению](#WEB)
  
# 5. REST vs RPC. Как выбрать что лучше подходит?

Для работы с данными это обычно всегда REST

Для работы с действиями, операциями(logout,login,signin) RPC будет смотреться лучше

RPC - все описывает глаголами, а REST - существительными

[К оглавлению](#WEB)

# 6. Назовите 6 принципов REST API

+ Клиент-серверная архитектура: Клиент и сервер работают независимо друг от друга. Клиент отправляет запросы на сервер, сервер их принимает и возвращает ответы. Это позволяет развиваться клиенту и серверу независимо друг от друга 
+ Stateless (Отсутствие состояния): Сервер не сохраняет информацию о состоянии клиента между запросами. Информация о текущей сессии должна целиком храниться у клиента 
+ Кеширование: В REST API сервер может запомнить результаты частых запросов, чтобы быстрее их вернуть и не тратить ресурсы на повторные вычисления. 
+ Единообразие интерфейса: В API используются стандартные команды (GET, POST, PUT, DELETE), чтобы взаимодействие было простым и предсказуемым 
+ Многоуровневость системы: Система может быть разделена на несколько слоев, каждый из которых выполняет свою задачу 
+ Код по требованию: Иногда сервер может отправлять клиенту код (например, скрипты), который клиент может использовать для выполнения задач

[К оглавлению](#WEB)

# 7. Идемпотентный метод

Идемпотентность — это свойство HTTP-запроса, при котором повторный вызов запроса дает тот же результат, что и первый вызов (без дополнительных побочных эффектов).

### Идемпотентные HTTP-методы
| Метод   | Описание                                    | Идемпотентен?                         |
|---------|---------------------------------------------|---------------------------------------|
| GET     | Получение ресурса                           | Да                                    |
| HEAD    | Получение мета-информации (без тела ответа) | Да                                    |
| PUT     | Обновление ресурса (замена)                 | Да                                    |
| DELETE  | Удаление ресурса                            | Да (если сервер реализован правильно) |
| OPTIONS | Запрос доступных методов для ресурса        | Да                                    |

```java
Пример PUT (идемпотентность)

PUT /users/1
{
    "name": "Alice",
    "email": "alice@example.com"
}

Если выполнить 100 раз, 
то состояние не изменится – запись просто перезапишется
```

### Неидемпотентные методы

| Метод | Описание             | Идемпотентен? |
|-------|----------------------|---------------|
| POST  | Создание ресурса     | Нет           |
| PATCH | Частичное обновление | Нет           |

```java
Пример POST (НЕ идемпотентный)

POST /users
{
    "name": "Alice",
    "email": "alice@example.com"
}

Если выполнить 100 раз, то создастся 100 пользователей.
```

[К оглавлению](#WEB)

# 8. Основные HTTP методы

+ GET. Получение ресурса. 
+ POST. Создание нового ресурса. 
+ PUT. Полное обновление ресурса или создание, если его нет. 
+ PATCH. Частичное обновление ресурса. 
+ DELETE. Удаление ресурса. 
+ HEAD. Получение заголовка ресурса 
+ OPTIONS. Узнать доступные методы для ресурса

[К оглавлению](#WEB)

# 9. Статусы ответов

+ 100-199. Информационные 
+ 200-299. Успешные 
+ 300-399. Перенаправления 
+ 400-499. Клиентские ошибки 
+ 500-599. Серверные ошибки

[К оглавлению](#WEB)

# 10. GET vs POST

| Критерий             | GET                                                    | POST                                                      |
|----------------------|--------------------------------------------------------|-----------------------------------------------------------|
| Назначение           | Получение данных                                       | Создание или изменение данных.                            |
| Передача данных      | Данные передаются в URL (в строке запроса).            | Данные передаются в теле (body) HTTP-запроса              |
| Безопасность         | Менее безопасный (данные видны в URL и логах сервера)  | Более безопасный (данные не видны в URL)                  |
| Идемпотентность      | Идемпотентен (повторный запрос не изменяет состояние). | Не идемпотентен (повторный запрос может создать дубликат) |
| Кэширование          | Поддерживается браузерами и прокси-серверами           | Не поддерживается кэширование по умолчанию                |
| Ограничение на длину | Ограничения на длину строки URL зависят от браузера    | Ограничения на длину тела запроса обычно отсутствуют      |
| Пример использования | Поиск данных, отображение страниц.                     | Отправка форм, создание ресурсов, изменение данных        |

### Почему для конфиденциальных данных рекомендуется использовать POST, а не GET запросы

`Безопасность`:
+ В GET запросе данные передаются в URL, который может быть виден в истории браузера, логах сервера и прокси. 
+ В POST данные передаются в теле запроса, что снижает риск случайной утечки.

`Ограничения длины`:
+ Длина URL в GET ограничена браузерами или серверами, поэтому большие объемы данных (например, конфиденциальные формы) могут не пройти. При использовании метода GET можно использовать не более 2048 символов за вычетом количества символов в фактическом пути.

`Кэширование`:
+ GET запросы могут быть кэшированы прокси-серверами или браузерами, что нежелательно для конфиденциальной информации.

### Можем ли всегда использовать только POST и не работать с GET?

Теоретически — да, но это нарушает принципы REST и архитектуру веб-приложений:

`REST-принципы`:

+ GET предназначен для получения данных, POST — для создания. Использование POST для всех операций затрудняет понимание и поддержку API.

`Оптимизация и кэширование`:
+ GET запросы могут быть кэшированы, что ускоряет работу. POST запросы не кэшируются по умолчанию.

`Поисковые системы и SEO`:
+ GET используется для индексации страниц. Если использовать только POST, страницы не попадут в поисковую выдачу.

### Можем ли с помощью GET создать ресурс? Есть ли технические ограничения?

+ Технические ограничения: С точки зрения HTTP-протокола, GET не должен создавать ресурсы. Но технически сервер может обрабатывать GET запросы так, чтобы они изменяли данные (например, создавали ресурс).
+ Практика: Создание или изменение ресурсов через GET нарушает идемпотентность и может вызвать проблемы с кэшированием и повторными запросами.
+ Рекомендация: Для создания ресурсов всегда следует использовать POST, чтобы соблюсти семантику HTTP и избежать неожиданных ошибок

### Почему решили из метода GET убрать body?

`Неопределённое поведение`:

+ Семантика GET подразумевает только получение данных. Тело запроса не является обязательной частью этой семантики, поэтому серверы могут игнорировать его.

`Совместимость`:
+ Многие прокси-серверы, фреймворки и библиотеки не поддерживают body в GET, что могло бы привести к проблемам совместимости.

`Простота и идемпотентность`:
+ GET запросы считаются идемпотентными и безопасными. Наличие тела могло бы изменить эту концепцию, создавая больше путаницы.

`Архитектурное решение`:

+ Для сложных запросов с данными в теле рекомендуется использовать POST, а для простых запросов — GET. Это упрощает архитектуру и делает API предсказуемым.

[К оглавлению](#WEB)

# 11. Разница HTTP и HTTPs

| Критерий              | HTTP                                                     | HTTPs                                                                                                                           |
|-----------------------|----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| Безопасность данных   | Данные передаются в открытом виде (без шифрования)       | Использует шифрование (обычно с помощью SSL/TLS)                                                                                |
| Протоколы             | Работает по порту 80                                     | Работает по порту 443                                                                                                           |
| Сертификаты           | Не требует сертификатов                                  | Требует установки SSL/TLS-сертификата на сервере, чтобы подтвердить подлинность сайта и обеспечить шифрование                   |
| Доверие пользователей | Браузеры могут помечать сайты на HTTP как “небезопасные” | Сайты с HTTPS отображаются с иконкой замка в адресной строке, что повышает доверие.                                             |
| Производительность    | Быстрее, так как не требует шифрования данных            | Немного медленнее из-за накладных расходов на шифрование, но современные технологии (например, HTTP/2) минимизируют эту разницу |

[К оглавлению](#WEB)

# 12. Из чего состоит HTTP запрос

| Часть                           | Описание                                                                                                                         |
|---------------------------------|----------------------------------------------------------------------------------------------------------------------------------|
| Стартовая строка (Request Line) | Содержит метод запроса, URL-адрес и версию протокола HTTP. Например: GET /index.html HTTP/1.1.                                   |
| Заголовки (Headers)             | Метаданные о запросе: тип содержимого, длина, информация об авторизации и многое другое. Пример: Content-Type: application/json. |
| Пустая строка                   | Разделяет заголовки и тело запроса                                                                                               |
| Тело запроса (Body)             | Непосредственно данные, которые передаются серверу (например, JSON, XML, файл). Присутствует не всегда                           |

[К оглавлению](#WEB)

# 13. Какие методы авторизации существуют для HTTP протокола?

| Метод                 | Описание                                                                                                             | Особенности                                                                                     |
|-----------------------|----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| Basic Authentication  | Клиент отправляет логин и пароль, закодированные в Base64, в заголовке Authorization: Basic <encoded_credentials>.   | Уязвим для перехвата без использования HTTPS. Рекомендуется использовать в сочетании с SSL/TLS. |
| Bearer Token          | Клиент отправляет токен в заголовке Authorization: Bearer <token>.                                                   | Используется с OAuth2 и JWT. Удобен для работы с API.                                           |
| Digest Authentication | Сервер отправляет клиенту nonce (одноразовый токен), который клиент использует для хеширования своих учетных данных. | Устаревший метод, сложен в реализации, менее популярен.                                         |
| OAuth 2.0             | Механизм авторизации через сторонние сервисы. Клиент получает токен доступа от сервера авторизации.                  | Расширяемый, позволяет использовать сторонние приложения (например, Google, Facebook).          |
| API Key               | Клиент отправляет ключ API в заголовке, URL или параметре запроса                                                    | Прост, но менее безопасен. Требует защищенной передачи (HTTPS)                                  |
| Session-based         | Клиент сохраняет идентификатор сессии в cookie, а сервер проверяет сессию по базе данных.                            | Широко используется в веб-приложениях, требует управления серверной сессией.                    |
| Custom Authentication | Использование кастомных токенов или механизмов авторизации                                                           | Гибкость, но требует больше усилий для реализации и обеспечения безопасности                    |
| Mutual TLS            | Двусторонняя аутентификация с использованием сертификатов TLS                                                        | Высокий уровень безопасности, сложен в настройке.                                               |

[К оглавлению](#WEB)
 
# 14. Из чего состоит JSON Web Token?

JWT — это стандартный способ передачи информации в компактном формате (JSON), подписанного для обеспечения его целостности и подлинности. Используется для авторизации, передачи данных между клиентом и сервером.

### Из чего состоит JWT?

JWT состоит из трех частей, разделенных точками (.): `<Header>.<Payload>.<Signature>`

`Header (Заголовок)`: Содержит метаинформацию о токене:
+ Алгоритм подписи (например, HMAC SHA256, RSA).  
+ Тип токена (JWT).

```java
{
  "alg": "HS256",
  "typ": "JWT"
}
```

`Payload (Полезная нагрузка)`: Содержит данные (клеймы), которые нужно передать. Может включать:
+ Зарезервированные клеймы: стандартные поля, такие как iss (издатель), exp (время истечения), sub (тема). 
+ Пользовательские клеймы: любые данные, такие как роль пользователя, идентификатор и т.д.

```java
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

`Signature (Подпись)`: Подписывает токен, чтобы проверить его подлинность. Формируется с использованием заголовка, полезной нагрузки и секретного ключа (или приватного ключа в случае асимметричного шифрования).

```java
Пример формулы

HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

```java
Пример JWT (для кодирования/декодирования можно использовать ресурс jwt.io):

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
        
Header (Base64 URL):
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
        
Payload (Base64 URL):
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0

Signature:
KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
```

[К оглавлению](#WEB)

# 15. Какие протоколы уровня приложений?

Протоколы уровня приложений – это 7-й уровень модели OSI, который отвечает за взаимодействие приложений по сети.

### Основные протоколы:

+ HTTP, HTTPS – передача данных в вебе 
+ FTP, SFTP – передача файлов 
+ SMTP, POP3, IMAP – почтовые протоколы 
+ WebSockets – двусторонняя связь в реальном времени 
+ DNS – преобразование доменов в IP 
+ MQTT – обмен сообщениями в IoT 
+ gRPC – бинарный протокол для микросервисов

````
Пример использования

Браузер (Chrome, Firefox) → использует HTTP/HTTPS
Почтовый клиент (Outlook, Gmail) → использует IMAP/SMTP
FTP-клиент (FileZilla) → использует FTP/SFTP
````

[К оглавлению](#WEB)

# 16. Что такое HTTP?

HTTP (HyperText Transfer Protocol) – это протокол передачи гипертекста, который используется для взаимодействия браузеров и серверов.

### Ключевые характеристики HTTP:

+ Клиент-серверная модель (браузер – клиент, сервер – сайт)
+ Stateless (без сохранения состояния)
+ Текстовый протокол (легко читается)
+ Работает поверх TCP (обычно порт 80 для HTTP, 443 для HTTPS)

[К оглавлению](#WEB)

# 17. За что отвечают Cookie/куки?

Cookie – это небольшой файл с данными, который браузер сохраняет от имени веб-сайта. Они передаются между клиентом и сервером через заголовки HTTP.

### Основные задачи Cookie:

+ Аутентификация – хранение сессии пользователя (JSESSIONID, session_token). 
+ Персонализация – запоминание настроек (язык, тема сайта). 
+ Трекинг и аналитика – сбор данных о пользователях (Google Analytics). 
+ Сохранение корзины – хранение товаров в интернет-магазине.

### Как работает Cookie?

+ Сервер отправляет Cookie клиенту (браузеру).

```java
Set-Cookie: session_id=abc123; HttpOnly; Secure; Max-Age=3600
```

+ Клиент сохраняет Cookie и отправляет их при каждом запросе

```java
Cookie: session_id=abc123
```

+ Сервер проверяет Cookie и принимает решение (например, авторизация).

### Виды Cookie

| Тип Cookie        | Описание                                        |
|-------------------|-------------------------------------------------|
| Session Cookie    | Удаляются после закрытия браузера               |
| Persistent Cookie | Хранятся определенное время (Max-Age, Expires)  |
| HttpOnly Cookie   | Доступны только серверу (JS не может прочитать) |
| Secure Cookie     | Отправляются только по HTTPS                    |
| SameSite Cookie   | Защита от CSRF (можно ограничить передачу)      |

```java
Пример Set-Cookie с атрибутами

Set-Cookie: user=Alice; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict
```

[К оглавлению](#WEB)

# 18. Отличия POST, PUT, PATCH

| Метод | Назначение                                               | Идемпотентность               | Тело запроса                | Пример использования                                  |
|-------|----------------------------------------------------------|-------------------------------|-----------------------------|-------------------------------------------------------|
| POST  | Создание нового ресурса или выполнение некой операции    | Неидемпотентен                | Полные данные для создания  | POST /users (создать нового пользователя)             |
| PUT   | Полная замена ресурса (или создание, если не существует) | Идемпотентен                  | Полные данные для ресурса   | PUT /users/123 (заменить пользователя с ID=123)       |
| PATCH | Частичное обновление ресурса                             | Неидемпотентен (по стандарту) | Данные с изменяемыми полями | PATCH /users/123 (обновить только email пользователя) |

`POST`:

+ Используется для создания или запуска операций, которые могут изменять состояние на сервере. 
+ Повторный вызов POST может приводить к дублированию ресурсов (неидемпотентность).

`PUT`:

+ Обычно подразумевает полное обновление ресурса по указанному URI. 
+ Идемпотентность: повторный вызов с тем же телом запроса не изменит результат (если ресурс уже существует).

`PATCH`:

+ Позволяет частично обновлять ресурс (передаём только изменяемые поля). 
+ Часто не считается идемпотентным, так как повторное применение PATCH может привести к другим изменениям, но многое зависит от реализации.

Таким образом, POST чаще всего используется для создания, PUT – для полной замены (или создания, если ресурс отсутствует), а PATCH – для частичного обновления.

[К оглавлению](#WEB)
